# 什么是表达式

- 表达式，由一个或多个运算对象组成。

  > 可以这么说：
  >
  > - 运算对象是表达式；
  > - 运算对象与运算符组合起来，是表达式。

  > 字面值和常量，是最简单的表达式。

- 表达式会返回一个结果。



# 理解复合表达式

对于复杂的表达式，要想理解它的含义， 需要先理解运算符的：

- 优先级(precedence)
- 结合律(associativity)
- 运算对象的求值顺序（order of evaluation)



## 优先级与结合律

1. 先考虑优先级
2. 优先级相同时，其组合规则由结合律决定

> 但括号`()`，将无视优先级和结合律，将优先运算。



例如：3 + 4*5 + 6

1. 先考虑乘法运算，即得到表达式： 3 + 20 + 6
2. 再考虑结合律，+ 运算为左结合，即先算 3 + 20，则算23 + 6



## 求值顺序

- 优先级与结合律，规定了运算对象的组合方式，但却没用说明运算对象按照什么顺序求值。
- **运算对象的求值顺序，与优先级和结合律无关**。

> 例如：
>
> `f() + g()*h() + j()`
>
> - 根据优先级，g()和h()的返回值相乘
>
> - 根据结合律，f()的返回值先与g()和h()的乘积相加，所得结果再与j()的返回值相加。
>
> - 但却不知道，先计算谁的返回值。

> 再例如：
>
> ·`cout << i << ++i << endl;`
>
> 我们知道要将先输出左边的值（即 i），再输出右边的值（即 ++i）。
>
> 但先计算左边的值，还是先计算右边的值，因此该表达式是未定义的。



只有四种运算符，明确规定了运算对象的求值顺序：

- `&&`：只有左侧运算对象为假，才会计算右值对象的值。
- `||`
- `?:`
- `,`





# 运算符重载

- 可以决定：
  - 对象的类型
  - 返回值的类型
- 但不可以更改：
  - 运算对象的个数
  - 运算符的优先级、结合律。





# 左值与右值

- 一个对象，被当作 ... 使用时：

  - 右值：

    使用的该对象的值（内容）

  - 左值：

    使用的是该对象的身份（内存地址）

- **在需要使用右值的地方，可以使用左值来代替**，此时将使用左值的内容（值）。

  但不能反之。

- 不同的运算符，对运算对象的要求各不相同。

  有的需要左值运算对象，有的需要右值。

- 运算的返回值也不同，有的得到左值结果，有的得到右值结果。







# 运算符

## 算术运算符

![image-20220715145524788](%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20220715145524788.png)

- 优先级：一元运算符 > 乘除 > 加减
- 结合律：左结合
- 运算对象：右值
- 求值结果：右值

> **在表达式求值之前，参与的运算对象类型将被提升**，直到所有运算对象的类型统一。



## 逻辑和关系运算符

![image-20220715150238809](%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20220715150238809.png)

- 运算对象：右值
- 求值结果：右值



## 赋值运算符

**赋值**运算符：

- 结合律：**右结合**。

- 左值运算对象：要求一个可修改的左值（非常量）
- 返回结果：<font color="red">一个左值</font >，即它的左侧运算对象

> ### 💡注意
>
> `=`，即可表示赋值，也可以表达初始化。
>
> 此处讲的是赋值。



- 注意区分初始化，与赋值：

  ```C++
  int i = 0, j = 0, k = 0; // 初始化为非赋值
  const int ci = 1 ;	// 初始化而非赋值
  ```

- 左侧元素对象，需要一个左值对象：

  ```C++
  1024 = k;	// 错误：字面值是右值
  i + j = k;	// 错误：算术表达式是右值
  ci = k;		// 错误：ci是不可修改的左值
  ```

- 结合性，为右结合：

  ```C++
  int a,b;
  a=b=2;	//等价于： b=2; a=b;
  ```

  

## 成员访问运算符

- `.`和`->`，都可用于访问成员。

  > `ptr->mem`，等价于`(*ptr).mem`

- 但返回结果存在区别：

  - `.`：

    - 成员所属对象为左值，返回左值
    - 成员所属对象为右值，返回右值

  - `->`：

    返回结果是左值



## 条件运算符?:

```C++
cond ? expr1 : expr2;
```

- <font color="red">求值顺序</font>：

  1. 先求cond的值
  2. 再求 expr1 或 expr2

- 结合性：右结合

  ```C++
  finalGrade = (grade>90) ? "high"
      : (grade< 60) ? "fail" : "pass";
  ```

  第二行是一个整体，而非第一行与第二个问号前为一个整体。

- 返回结果：

  - 两个表达式，都是左值；或能转换为同一种左值类型时：返回左值
  - 否则：返回右值

- 优先级：很低



## 位运算符

- 作用于：整数类型的运算对象

- 运算符功能如下：

  ![image-20220715162612101](%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20220715162612101.png)

- 移位运算符的结合性：左结合



## sizeof运算符

- 功能：返回所占的字节数

- 结合律：右结合

- 返回结果：

  `size_t`类型的常量表达式

> sizeof，并不会对表达式进行实际运算



运算结果，依赖于所作用的类型：

- 普通类型：得到对应的字节数

- 引用类型：被引用对象的字节数

- 指针：指针本身的大小

- 解引用指针：指针所指空间的大小。

  > 即便指针为NULL也没关系，并不进行计算。

- 数组：整个数组的大小。

  > 此处，不会把数组转换为指针来处理。



## 逗号运算符

- <font color="red">求值顺序</font>：从左到右
- 返回结果：
  - 返回右侧表达式的值
  - 如果右侧对象为左值，则最终结果也为左值。



## 取地址符

```C++
int a, b;
int *ptr;

ptr = &(b = 2);
cout << &b << endl;   // 0x61fe14
cout << ptr << endl;  // 0x61fe14
```

- 作用于：一个左值运算对象
- 返回：一个指向该运算对象的指针，该指针为右值。



## 运算符优先级表

![image-20220715174642257](%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20220715174642257.png)

![image-20220715174657631](%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20220715174657631.png)



# 类型转换

## 隐式类型转换

隐式转换，是由编译器自动执行的，无需程序员介入。

例如：

```C++
int ival = 3.541 + 3;
```

1. 先将3转换为double，计算+，得到结果4.541
2. 将4.541，转换为int类型，即4





何时发生隐式类型转换：在下面这些情况中，编译器将自动地转换运算对象的类型：

- 比int小的整数值，首先提升为较大的整数类型
- 在条件中，非布尔值，转换为布尔类型
- 初始化过程中，初始值转换成变量的类型
- 赋值语句中，右侧对象转换为左侧对象的类型
- 算术运算或关系运算的运算对象类型不同，则需要转换为同种类型
- 函数调用时



- 数组名，转换为指向首元素的指针：

  <font color="red">不会发生的情况</font>：

  - 用作`decltype`关键字的参数
  - 作为`&`, `sizeof`,`typeid`等运算符的运算对象时
  - 用引用初始化数组

- 指针的转换：

  - 常量整数值0，字面值nullptr，能转换为任意指针类型
  - 指向任意非常量对象的指针，能转换为void*
  - 指向任意对象的指针，能转换为const void*
  - 子类型指针，能转换为父类型指针

- 算术类型和指针类型，转换为布尔类型

- 转换成常量：

  - 指向非常量的指针，能转换为对应常量类型的指针
  - 引用也同理

- 类类型定义的转换：

  类类型，能定义由编译器自动执行的转换。



## 算术转换

- 什么是算术转换：

  一套算术类型转换的规则。运算符的运算对象，统一转换为最宽的类型。



### 整形提升

负责将：小整数类型，转换为较大的整数类型。

例如：

- bool, char, signed char, unsigned char, short, unsigned short，如果int存的下，则转换为int；否则转为unsigned int

- 较大的char类型（wchar_t, char16_t, char32_t），提升为int, unsigned int, long, unsigned long, long long, unsigned long long中最小的类型。



### 无符号类型参与运算

当无符号类型参与运算：

1. 像往常一样，首先执行整形提升。

2. 若两个提升后的运算对象，要么都是带符号的、要么都是无符号的，则小类型，转换为较大类型。

3. 此步的前提：一个是无符号类型，一个是有符号类型。

   - 若无符号类型 >= 带符号类型：带符号类型转换为无符号类型。

   - 若反之，则依赖于机器：

     - 若无符号类型，能被带符号类型表示：转为带符号类型。

       long 和 unsigned int，并且long比int占用空间多，则unsigned int转为long。

     - 若反之：转换为无符号类型。

       long 和 unsigned int，并且int和long的大小相同，则long转为unsigned int。



### 算术转换的例子

![image-20220715170129291](%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20220715170129291.png)

![image-20220715170119174](%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20220715170119174.png)

第一个例子中，'a'对应的数值为97。其与long double类型相加时，char类型将先提升为int，然后int类型再转换为long double类型。



总结：

- 非字符类型：
  1. 先提升为int 或 unsigned int
  2. 在根据对方做类型转换
- 字符类型：
  1. 先提升为int, unsigned int, long, unsigned long, long long, unsigned long long中最小的类型
  2. 在根据对方做类型转换



## 显式转换

语法：

`cast-name<type>(expression)`

- type是转换的目标类型
- expression是要转换的值
- 若type为引用类型，则结果为左值。



### statis_cast

只要不包含底层const，都可以使用static_cast。



```C++
int i,j;
double slope = static_cast<double>(j) / i;
```



```C++
void *p = &d;	// 任何非常量对象的地址，都可以存入 void*
double *dp = static_cast<double*>(p);
```

> 一般用于把void*指针，转换真实类型。



### const_cast

只能用于改变对象的底层const。

- 去掉const性质：

  ```C++
  const char *pc;
  char *p = const_cast<char*>(pc);	// 正确。但通过p写值是未定义的行为。
  ```

> 一般用于把const T* / const T&，去掉底层const，得到真实类型。



### reinterpret_cast

为运算对象的位模式，提供较低层次上的重新解释。

```C++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

pc所指的实际对象是int，而非char。如果把pc当作普通的字符指针，可能在运行时发生错误。

例如：`string str(pc);`



### dynamic_cast

支持运行时类型识别。



