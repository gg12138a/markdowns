# 概述

创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“**<u>将对象的创建与使用分离</u>**”。

这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。

创建型模式分为：

* 单例模式
* 工厂方法模式
* 抽象工程模式
* 原型模式
* 建造者模式



# 单例设计模式（Singleton Pattern）

## 结构

单例模式的主要有以下角色：

* 单例类：只能创建一个实例的类
* 访问类：使用单例类的类



## 实现

单例设计模式分类两种：

- 饿汉式：***类加载就会导致该单实例对象被创建***


- 懒汉式：类加载不会导致该单实例对象被创建，而是***首次使用该对象时才会创建***



### 饿汉式

#### 静态变量方式

```java
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance = new Singleton();

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return instance;
    }
}
```

- instance对象是随着类的加载而创建的。
- 如果该对象足够大的话，而一直没有使用就会<u>造成内存的浪费</u>。



#### 静态代码块方式

```java
public class Singleton {

    private Singleton() {}

    private static Singleton instance;

    static {
        instance = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return instance;
    }
}
```

- 该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。

- 所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。



#### 枚举方式

枚举类型是所用单例实现中，***唯一一种不会被破坏的单例实现模式***。

```java
public enum Singleton {
    INSTANCE;
}
```



> 枚举是线程安全的。



### 懒汉式

#### 线程不安全的实现

```java
public class Singleton {
    private Singleton() {}

    private static Singleton instance;

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {

        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

- 当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。
- 但是，如果是多线程环境，会出现线程安全问题。



#### 线程安全的方式(synchronized)

```java
public class Singleton {
    private Singleton() {}

    private static Singleton instance;

    //对外提供静态方法获取该对象
    public static synchronized Singleton getInstance() {

        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

- 该方式也实现了懒加载效果，同时又解决了线程安全问题。

- 但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。

  >因为只有在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在。而synchronized将导致即便创建了对象，仍需要竞争锁



#### 双重检查锁

对于 `getInstance()` 方法来说，绝大部分的操作都是读操作，***读操作是线程安全的***，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式

```java
public class Singleton { 
	private Singleton() {}

    private static volatile Singleton instance;

    public static Singleton getInstance() {
        if(instance == null) {
            
           	// 可能存在多个线程进入if块争抢锁。
            // 只要对象已经创建完毕，剩余的线程应全部直接返回
            synchronized (Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        
        return instance;
    }
}
```



> 若不添加`volatile`关键字，由于JVM在实例化对象的时候会进行优化和指令重排序操作，可能在多线程环境下导致空指针问题



#### 静态内部类

静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, <u>**只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性**</u>。

```java
public class Singleton {

    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

> 也就是说，利用了类加载本身的线程安全性，结合的按需加载内部类的特性



## 破坏单例模式

> 仅枚举方式，是不可被破坏的。



### 两种破坏方式

存在两种破坏方式：

- 序列化和反序列化：

  **Singleton类：**

  ```java
  public class Singleton implements Serializable {
  
      private Singleton() {}
  
      private static class SingletonHolder {
          private static final Singleton INSTANCE = new Singleton();
      }
  
      public static Singleton getInstance() {
          return SingletonHolder.INSTANCE;
      }
  }
  ```

  **Test类：**

  ```java
  public class Test {
      public static void main(String[] args) throws Exception {
          //往文件中写对象
          //writeObject2File();
          
          //从文件中读取对象
          Singleton s1 = readObjectFromFile();
          Singleton s2 = readObjectFromFile();
  
          //判断两个反序列化后的对象是否是同一个对象
          System.out.println(s1 == s2);	//false
      }
  
      private static Singleton readObjectFromFile() throws Exception {
          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("C:\\Users\\Think\\Desktop\\a.txt"));
          Singleton instance = (Singleton) ois.readObject();
  
          return instance;
      }
  
      public static void writeObject2File() throws Exception {
          Singleton instance = Singleton.getInstance();
          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("C:\\Users\\Think\\Desktop\\a.txt"));
          //将instance对象写出到文件中
          oos.writeObject(instance);
      }
  }
  ```

  > 上面代码运行结果是`false`，表明序列化和反序列化已经破坏了单例设计模式。

- 反射：

  **Singleton类：**

  ```java
  public class Singleton {
  
      private Singleton() {}
      
      private static volatile Singleton instance;
  
      public static Singleton getInstance() {
  
          if(instance != null) {
              return instance;
          }
  
          synchronized (Singleton.class) {
              if(instance != null) {
                  return instance;
              }
              instance = new Singleton();
              return instance;
          }
      }
  }
  ```

  **Test类：**

  ```java
  public class Test {
      public static void main(String[] args) throws Exception {
          Class clazz = Singleton.class;
          
          //获取Singleton类的私有无参构造方法对象
          Constructor constructor = clazz.getDeclaredConstructor();
          constructor.setAccessible(true);
  
          Singleton s1 = (Singleton) constructor.newInstance();
          Singleton s2 = (Singleton) constructor.newInstance();
  
          //判断通过反射创建的两个Singleton对象是否是同一个对象
          System.out.println(s1 == s2);	//false
      }
  }
  ```

  > 上面代码运行结果是`false`，表明序列化和反序列化已经破坏了



### 解决方案

- 序列化和反序列化的解决方案：

  在Singleton类中添加`readResolve()`方法：

  该方法将在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。

  ```java
  public class Singleton implements Serializable {
  
      private Singleton() {}
  
      private static class SingletonHolder {
          private static final Singleton INSTANCE = new Singleton();
      }
  
      public static Singleton getInstance() {
          return SingletonHolder.INSTANCE;
      }
      
      /**
       * 下面是为了解决序列化反序列化破解单例模式
       */
      private Object readResolve() {
          return SingletonHolder.INSTANCE;
      }
  }
  ```


  源码解析：ObjectInputStream类

  ```java
  public final Object readObject() throws IOException, ClassNotFoundException{
      ...
      // if nested read, passHandle contains handle of enclosing object
      int outerHandle = passHandle;
      try {
          Object obj = readObject0(false);//重点查看readObject0方法
      .....
  }
      
  private Object readObject0(boolean unshared) throws IOException {
  	...
      try {
  		switch (tc) {
  			...
  			case TC_OBJECT:
  				return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法
  			...
          }
      } finally {
          depth--;
          bin.setBlockDataMode(oldMode);
      }    
  }
      
  private Object readOrdinaryObject(boolean unshared) throws IOException {
  	...
  	//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，
      obj = desc.isInstantiable() ? desc.newInstance() : null; 
      ...
      // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true
      if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) {
      	// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量
      	// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。
      	Object rep = desc.invokeReadResolve(obj);
       	...
      }
      return obj;
  }
  ```

- 反射的解决方案：

  ```java
  public class Singleton {
  
      private Singleton() {
          /*
             反射破解单例模式需要添加的代码
          */
          if(instance != null) {
              throw new RuntimeException();
          }
      }
      
      private static volatile Singleton instance;
  
      public static Singleton getInstance() {
  
          if(instance != null) {
              return instance;
          }
  
          synchronized (Singleton.class) {
              if(instance != null) {
                  return instance;
              }
              instance = new Singleton();
              return instance;
          }
      }
  }
  ```

  当通过反射方式调用构造方法进行创建创建时，直接抛出异常。不运行此种操作。



## JDK中案例-Runtime类

```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    /**
     * Returns the runtime object associated with the current Java application.
     * Most of the methods of class <code>Runtime</code> are instance
     * methods and must be invoked with respect to the current runtime object.
     *
     * @return  the <code>Runtime</code> object associated with the current
     *          Java application.
     */
    public static Runtime getRuntime() {
        return currentRuntime;
    }

    /** Don't let anyone else instantiate this class */
    private Runtime() {}
    ...
}
```

> 即通过恶汉式（静态属性）方式来实现单例模式





- 

# 工厂方法模式

[黑马程序员Java设计模式详解，全网最全23种Java设计模式（图解+框架源码分析+实战）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Np4y1z7BU?p=34)



# 抽象工厂模式



# 原型模式



# 建造者模式