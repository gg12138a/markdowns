# IMPORTANT

- <font color="red">参数传递的语义，与拷贝初始化的语义完全一致</font>。

- 函数返回值的语义，也与拷贝初始化的语义完全一致。

  



# 传递给Const T&

字面值、常量、需要执行类型转换的参数，可以传递给const T&类型：

```c++
float fsqrt(const float&);

void g(double d){
    float r = fsqrt(2.0f);		// 传递存放2.0f的临时对象的引用
	r = fsqrt(r);				// 传递r的引用
    r = fsqrt(d);				// 传递存放static_cast<float>(d)的临时变量的引用
}
```





# 数组作为形参

- 当数组作为形参时，`T[]`等同于`T*`
- 当数组名作为实参时，传递是指向首元素的指针。



> 如果确实想传入一个数组而非指针，使用引用：
>
> ```c++
> void f(int(&r)[4]);
> ```





# `{}`作为实参

{}限定的列表，可以作为如下形参的实参：

- std::initializer_list\<T>，其中列表中的值能隐式转换为T

  ```C++
  template<class T>
  void f1(initializer_list<T>);
  
  f1({1,2,3,4});
  ```

- 能用列表中的值，初始化的类型

  ```C++
  Struct S{
      int a;
      string s;
  };
  void f2(S);
  
  f2({1,"jhe"});
  ```

- T类型数组的引用，其中列表中的值能隐式转换为T

  ```C++
  template<class T, int N>
  void f3(T(&r)[N]);
  
  f3({1,2,3,4});
  ```

  



# 数量未定的参数

对于某些函数来说，很难明确指明，调用时期望的参数类型和数量。



要实现这样的接口，存在三种选择：

- 使用可变模板：

  允许我们以类型安全的方式，处理任意类型、任意数量的实参。

- 使用initializer_list：

  允许我们以类型安全的方式，处理**某种类型**、任意数量的实参。

- 使用`...`结束参数列表：

  允许我们通过使用\<cstdarg>中的宏，处理（几乎）任意类型、任意数量的参数。但并非类型安全。





# 重载函数的匹配

![image-20220723194931814](%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.assets/image-20220723194931814.png)





