# 相关资料

- [视频链接](https://www.bilibili.com/video/BV1RX4y157CM?spm_id_from=333.337.search-card.all.click)

- http://wyoos.org



- [Expanded Main Page - OSDev Wiki](https://wiki.osdev.org/Expanded_Main_Page)
- [OSDev Wiki CN - osdev (foofun.cn)](http://osdev.foofun.cn/index.php?title=OSDev_Wiki_CN)



# 解惑

## 软件是如何访问硬件的

方式有两种：

1. 将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存。

   如显卡。显卡是显示器的适配器， CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端 1MB 的0XB8000～0XBFFFF。 CPU 访问这片内存就是访问显存，住这片内存上写字节便是往屏幕上打印内容。

2. 外设是通过 IO 接口与 CPU 通信的， CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递给另一端的外设，也就是说， CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口。

   - 如何访问到 IO 接口呢？

     IO 接口上面有一些寄存器，访问 IO 接口本质上就是访问这些寄存器，这些寄存器就是人们常说的端口。这些端口是人家 IO 接口给咱们提供的接口。人家接口电路也有自己的思维（系统），看到寄存器中写了什么就做出相应的反应。



## 内存的分段访问

CPU 采用 “段基址＋段内偏移地址”的形式访问内存，就需要专门提供**段基址寄存器**，这些是 cs ds es 。程序中需要用到哪块内存，只要先加载合适的段到段基址寄存器中，再给出相对于该段基址的偏移地址便可， CPU 中的地址单元会将这两个地址相加后的结果用于内存访问，送上地址总线。



## 代码段与数据段

- x86 平台的处理器是必须要用分段机制访问内存的，正因为如此，处理器才提供了段寄存器，用来指定待访 问的内存段起始地址。

- 我们这里讨论的程序代码中的段（用 section segment 来定义的段，不同汇编编译器提供的关键字有所区别，功能是一样的）和内存访问机制中的段本质上是一回事。在硬件的内存访问机制中，处理器要用硬件——段寄存器，指向软件一一程序代码中用 section 或 segment 以软件形式所定义的内存段。

- 一般的高级语言不允许程序员自己将代码分成各种各样的段，这是因为其所用的编译器是针对某个操作系统编写的，该操作系统采用的是平坦模型，所以该编译器要编译出适合此操作系统加载运行的程序。
- 由于处理器支持了具有分页机制的虚拟内存，操作系统也采用了分页模型，因此**编译器会将程序按内容分成代码段和数据段**，如编译器 gcc 会把 C 语言写出的程序划分成代码段、数据段、栈段、.bss 段、堆等部分。这会由操作系统将编译器编译出来的用户程序中的各个段分配到不同的物理内存上。
  - 为了让程序内指令接连不断地执行，要把指令全部排在 起，形成一片连续的指令区域，这就是代码段。
  - 把数据连续地并排在一起存储形成的段，即为数据段。
  - 具有全局属性的但又未初始化的数据放在 bss 段



将数据和代码，分开的好处：

1. 为它们赋予不同的属性

   例如数据本身是需要修改的，所以数据就需要有可写的属性，不让数据段可写，那程序根本就无法执行啦。程序中的代码是不能被更改的，这样就要求代码段具备只读的属性。

2. 提供CPU内部缓存的命中率

3. 节省内存



## 段的保护是如何实现的

1. 编译器负责**挑选**出数据具备的属性，从而根据属性将程序片段分类，比如，划分出了只读属性的代码段和可写属性的数据段。

2. 操作系统通过设置 **GDT 全局描述符表**来构建段描述符，在段描述符中指定段的位置、大小及属性（包括 S 字段和 TYPE 字段）。

   也就是说，**操作系统**认为代码应该是只读的，所以给用来指向代码段的那个段描述符设置了只读的属性，这才是***真正给段添加属性的地方***。

3. CPU 中的段寄存器提前被操作系统赋予相应的选择子（后面章节会讲什么是选择子，暂时将其 理解为相当于段基址〉，从而确定了指向的段。**在执行指令时，会根据该段的属性来判断指令的行为，若有返回则发出异常**。

> 总之，编译器、操作系统、CPU 三个配合在一起，才能对程序进行保护，检测出指令的违规行为。



## 物理地址、逻辑地址、有效地址、线性地址、虚拟地址

![image-20220609235057433](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0.assets/image-20220609235057433.png)

- 实模式下：

  段基址 + 段内偏移地址 = 物理地址

- 保护模式下：

  段基址 + 段内偏移地址 = 线性地址

  段基址称作为“选择子”，本质是一个索引，通过本索引便能在 GDT 中找到相应的段描述符（描述符记录了段的信息（包含段基址））。

  - 若未开启地址分页功能：

    线性地址将被当作物理地址使用

  - 若开启：

    线性地址也称作虚拟地址，经过CPU 页部件转换成物理地址

> 参见《操作系统真象还原》 P11



## 段重叠现象

![image-20220609235706903](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0.assets/image-20220609235706903.png)

即：虽然两个段的段基址不同，其仍有可能访问到同一片地址空间



## sreg 段寄存器

CPU内部的段寄存器（Segment reg）如下：

- CS——代码段寄存器（Code Segment Register），其值为代码段的段基值。

- DS——数据段寄存器（Data Segment Register），其值为数据段的段基值。

- ES——附加段寄存器（Extra Segment Register），其值为附件数据段的段基值。

  此段寄存器的用途不像其他 sreg 那样固定，可以另作他用。

- FS一一附加段寄存器（ Extra Segment Register ），其值为附加数据段的段基值，同上，用途不固定， 使用上灵活机动。

- GS一一附加段寄存器（ Extra Segment Register ），其值为附加数据段的段基值。
- SS一一堆栈段寄存器（ Stack Segment Register ），其值为堆栈段的段值。



32 CPU 有两种不同的工作模式：

- 实模式：

  在实模式下， CS DS ES SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为 “段基值：段内偏移量”的形式。

- 保护模式：

  装入段寄存器的不再是段地址，而是“段选择子” (Selector),  当然，选择子也是数值，其依然为 16 位宽度。

>每种模式下，段寄存器中值的意义是不同的，但不管其为何值，在段寄存器中所表达的都是指向的段 在哪里。

>可见，在 32 CPU 中， sreg 无论是工作在 16 位的实模式，还是 32 位的保护模式，用的段寄存器都是同一组，并且在 32 位下的段选择子是 16 位宽度，排除了段寄存器在 32 位环境下是 32 位宽的可能。
>
>#### 💡 综上所述， sreg 都是 16 位宽。



## 大端字节序、小端字节序

> 参见《操作系统真象还原》 P19



- 内存的最小读写单位：字节

- 两种存储方式：（以存储0x12345678为例）

  - **小端字节**序：0x78,0x56,0x34,0x12

    - 数值的低字节，放在内存的低地址处。

    - 优势：数值低位在低字节，强转数据类型时无需调整字节。

  - 大端字节序：0x12,0x34,0x56,0x78

    - 数值的低字节，放在内存的高地址处。
    - 优势：符号位固定在第一字节，容易判断正负。



常见CPU的字节序：

- 大端字节序：IBM、Sun、PowerPC

- 小端字节序：x86、DEC

  > ARM架构的CPU则大小端都可，具体用哪类字节序由硬件**选择**。



> 字节序不仅体现在CPU访问内存时，也包含**文件存储和网络传输**。
>
> - bmp格式的图片，属于小端字节序
> - jpeg格式的图片，属于大端字节序
> - **网络字节序为大端字节序，因此x86架构上的程序在发送网络数据时，要转换字节顺序**。



## section 和 segment

- 可执行程序的section 称为节，是指在**汇编源码**中经由**关键字** section 或 segment 修饰、逻辑划分的指令或数据区域， 汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中
- 可执行程序的segment 称为段，是链接器根据**目标文件中属性相同的多个 section 合并后的 section 集合**，这个集合称为 segment ，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中，我们平时所说的可执行程序内存空间中的代码段和数据段就是指的 segment



## 如何控制CPU的下一条指令

- 在概念上，存放下一条指令地址的寄存器，**称为程序计数器 PC**

  也就是说 PC 用来表示下 条指令的存放地址，具体的实现形式不限

- 在x86 体系结构的 CPU 中（AMD & INTEL），***程序计数器 PC 并不是单一的某种寄存器，它是一种寄存器组合，指的段寄存器 CS 和指令指针寄存器IP。***

  >CS 和 IP，是CPU 待执行的下一条指令的段基址和段内偏移地址，不能直接用 mov 指令去改变它们。
  >
  >有专门改变执行流的指令，如 jmp call int ret ，这些指令可以同时修改 CS 和 IP，它们在硬件级别上实现了原子操作。

- ARM架构有专门的寄存器，就叫做PC。可以使用mov指令修改。



## MBR、EBR、DBR、OBR

> 这几个概念主要是围绕计算机系统的控制权交接展开的



1. 系统加电，运行基本输入输出系统BIOS。

   完成一些简单的检测和初始化工作。

2. BIOS将处理器使用权交由MBR。

   - MBR（主引导记录），位于整个硬盘最开始的那个扇区（CHS方式下的0盘0道1扇区）。
   - 一般情况下，扇区大小为512字节。MBR引导扇区中的内容：
     - 446字节的引导程序及参数
     - 64字节的分区表
     - 2字节结束标记0x55和0xaa

   **BIOS将把 0 盘 0道 1扇区中的MBR引导程序，加载到物理地址0x7c00，然后跳过去执行，从而完成处理器使用权移交**。

3. MBR在分区表中，通过辨识“活动分区”标记0x80，寻找活动分区。如果找到了，就将CPU使用权交给此分区上的引导程序，此引导程序通常是内核加载器。



# 部署工作环境

p53
