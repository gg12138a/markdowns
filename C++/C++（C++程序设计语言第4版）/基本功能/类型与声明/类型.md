# 标识符的作用

- C++程序中的**每个名字（即标识符），都对应着一种数据类型**。

- 该**数据类型，决定了对应的实体能执行的运算和如何执行运算**。

```C++
float x;		// x是一个float变量
int y=7;		// y是一个int变量
float f(int);	// f是一个函数，它接受一个int，返回float
```



# 基本类型

基本类型，对应了计算机最基本的存储单元，**并且展现了如何利用这些单元存储数据**。

- 布尔值类型：bool
- 字符类型：char, wchar_t
- 整数类型：int, long long
- 浮点数类型：double, long double
- void类型：表示类型信息缺少

> 布尔值、字符、整数：统称整形
>
> 整形、浮点型：统称为算术类型
>
> 枚举类型、类：称为用户自定义类型





基于基本类型，可以用**声明符**构造出更多类型：

- 指针类型：int*
- 数组类型：char[]
- 引用类型：double&

> 基本类型、指针、引用：通常为**内置类型**。



即<font color="red">内置类型的组成</font>：

- 基本类型
- 基于基本类型，结合声明符



## 字符类型

![image-20220720171355563](%E7%B1%BB%E5%9E%8B.assets/image-20220720171355563.png)



对于char, signed_char, unsigen_char：

- 不能混用这三种字符类型的指针，不存在对应的指针转换规则

- 但3中char类型的变量，可以相互赋值。

  但把一个比较大的值，赋给带符号的char，是未定义的行为。

  ![image-20220720172303423](%E7%B1%BB%E5%9E%8B.assets/image-20220720172303423.png)



- 字符字面值常量，如`'a'`：其数据类型是char
- 宽字符字面值常量，如`L'a'`，其数据类型是wchar_t





转义字符：

![image-20220720172443313](%E7%B1%BB%E5%9E%8B.assets/image-20220720172443313.png)



## 整数类型

> - long int即为long；
> - long long int即为long long；
> - short int即为short；
> - unsigned int即为unsigned；
> - signed int即为signed；
>
> > int类型，往往都是signed int的，虽然它们不是一种类型。



如果需要更精细地控制整数的尺寸，可以使用`<cstdint>`中定义的别名，例如int64_t。



整形字面值常量的类型，**由它的形式、取值、后缀共同决定**：

![image-20220720173510159](%E7%B1%BB%E5%9E%8B.assets/image-20220720173510159.png)

应使用后缀，避免对于实现平台的依赖性。



## 浮点数类型

- `1.23`，double类型
- `1.23F`，float类型



## 限定字面值常量的前后缀

![image-20220720174329576](%E7%B1%BB%E5%9E%8B.assets/image-20220720174329576.png)



## void

void仅可用于：

- 作为函数的返回类型，用于说明函数不返回任何实际的值；

  ```c++
  void f();
  ```

- 作为指针的基本类型部分，表明指针所指对象的类型位置。

  ```C++
  void* pv;
  ```



# 类型尺寸

不同的类型之间，体现的差异在：

- 内存需求
- 内存访问时间
- 计算时间

![image-20220720175050699](%E7%B1%BB%E5%9E%8B.assets/image-20220720175050699.png)



C++对基本类型尺寸的规定：

![image-20220720175206005](%E7%B1%BB%E5%9E%8B.assets/image-20220720175206005.png)



# 对齐

对象首先需要有足够的空间存放变量，但这还不够：

**存放变量的字节，必须保持一种良好的对齐方式，以便硬件访问数据资源时足够高效**（在极端情况下，一次性访问所有数据）。



- `alignof()`运算符，返回表达式的对齐情况：

  ```C++
  auto ac = alignof('c');
  ```

- 类型说明符`alignas(T)`：

  ```C++
  struct Obj{
      char arr[9];
      alignas(16) int a;
  }
  ```

  意味着，Obj::a的地址值必须能被16整除，这意味着arr[9]后面将插入7字节进行填充。

