# 相关资料

- [OIWIKI](https://oi-wiki.org/ds/heap/)



# 二叉堆(以大根堆为例)

## 插入操作 & 向上调整

最简单的方法就是，最下一层最右边的叶子之后插入。

如果这个结点的权值大于它父亲的权值，就交换，重复此过程直到不满足或者到根

![binary_heap_insert](%E5%A0%86.assets/binary_heap_insert-16566688202973.svg)



- 时间复杂度：$O(log n)$



## 删除操作 & 向下调整

1. 把根结点和最后一个结点直接交换，然后直接删掉（在最后一个结点处的）根结点

2. 对现有根节点进行**向下调整**：

   在该结点的儿子中，找一个最大的，与该结点交换，重复此过程直到底层



## 向上调整与向下调整——实现

我们发现，上面介绍的几种操作主要依赖于两个核心：**向上调整和向下调整**。



考虑使用一个序列 $h$ 来表示堆。 $h_i$的两个儿子分别是 $h_{2i}$ 和 $h_{2i+1}$ ，$1$ 是根结点：

![binary-heap-array](%E5%A0%86.assets/binary-heap-array.svg)



```C
void up(int x) {
  while (x > 1 && h[x] > h[x / 2]) {
    swap(h[x], h[x / 2]);
    x /= 2;
  }
}

void down(int x) {
  while (x * 2 <= n) {
    t = x * 2;
    if (t + 1 <= n && h[t + 1] > h[t]) t++;		// t是左孩子和右孩子中较大的那个
    if (h[t] <= h[x]) break;
    std::swap(h[x], h[t]);
    x = t;
  }
}
```

> 大根堆



## 建堆

### 一个个插入

- 时间复杂度：$O(nlogn)$



### 将无序数组整理为堆

- 使用向上调整：

  ```C
  void build_heap_1() {
    for (i = 1; i <= n; i++) up(i);
  }
  ```

- 使用向下调整：

  ```C
  void build_heap_2() {
    for (i = n; i >= 1; i--) down(i);
  }
  ```

  

- 时间复杂度：$O(n)$

  >之所以能$O(n)$建堆，是因为堆性质很弱，二叉堆并不是唯一的。





## 应用——对顶堆

>https://www.luogu.com.cn/problem/SP16254

核心在于：动态维护一个序列上第K大的数，k 值可能会发生变化。



对顶堆的组成：

- 一个小根堆：维护大值即前 k 大的值（包含第 k 个）
- 一个大根堆：维护小值即比第 大数小的其他数



这两个堆构成的数据结构支持以下操作：

- 维护：当小根堆的大小小于k时，不断将大根堆堆顶元素取出并插入小根堆，直到小根堆的大小等于 k；当小根堆的大小大于k 时，不断将小根堆堆顶元素取出并插入大根堆，直到小根堆的大小等于k ；
-  插入元素：若插入的元素大于等于小根堆堆顶元素，则将其插入小根堆，否则将其插入大根堆，然后维护对顶堆；
- 查询第 k 大元素：小根堆堆顶元素即为所求；
- 删除第 k 大元素：删除小根堆堆顶元素，然后维护对顶堆；



# 配对堆（可并堆）

配对堆是一个支持插入，查询/删除最小值，合并，修改元素等操作的数据结构，也就是俗称的可并堆。



## 定义

配对堆是一棵带权多叉树（如下图），其权值满足堆性质（**即每个节点的权值都小于他的所有儿子**）。

![img](%E5%A0%86.assets/pairingheap1.png)

通常我们使用左儿子右兄弟表示法储存一个配对堆（如下图），从下文可以看出这种方式可以方便配对堆的实现。

![img](%E5%A0%86.assets/pairingheap2.png)

## 实现

### 存储结构定义

```C
struct Node {
    T v;            // T为权值类型
    Node *ch, *xd;  // ch为该节点儿子的指针，xd为该节点兄弟的指针。
    // 若该节点没有儿子/兄弟则指针指向空节点 nullptr。
};
```



### 查询最小值

从配对堆的定义可看出，配对堆的根节点的权值一定最小，所以我们直接返回根节点



### 合并

配对堆的合并操作极为简单，直接把根节点权值较大的那个配对堆设成另一个的儿子就好了

![img](%E5%A0%86.assets/pairingheap3.png)

```C
Node* merge(Node* a, Node* b) {
    // 若有一个为空则直接返回另一个
    if (a == nullptr) return b;
    if (b == nullptr) return a;
    if (a->v > b->v) swap(a, b);  // swap后a为权值小的堆，b为权值大的堆
    // 将b设为a的儿子
    b->xd = a->ch;
    a->ch = b;
    return a;
}
```



### 插入

合并都有了，插入就直接把新元素视为一个新的配对堆和原堆合并就行啦。



### 删除最小值

考虑我们拿掉根节点之后会发生什么，根节点原来的所有儿子构成了一片森林，所以我们要把他们合并起来。

1. 把儿子们 **从左往右** 两两配成一对，用 `merge` 操作把被配成同一对的两个儿子合并到一起（见下图 1)

   ![img](%E5%A0%86.assets/pairingheap4.jpg)

2. 再将新产生的堆 **从右往左** 暴力合并在一起（见下图 2）。

   ![img](%E5%A0%86.assets/pairingheap5.jpg)



先实现一个辅助函数 `merges`，作用是合并一个节点的所有兄弟。

```C
Node* merges(Node* x) {
    if (x == nullptr || x->xd == nullptr)
        return x;  // 如果该树为空或他没有兄弟（即他的父亲的儿子数小于2），就直接return。
    
    Node *a = x->xd, *b = a->xd;  // a：x的一个兄弟，b：x的另一个兄弟
    x->xd = a->xd = nullptr;      // 拆散
    
    return merge(merge(x, a), merges(b));  // 核心部分
}
```

> 满足从左往右配对，从右往左合并



删除操作如下：

```C
Node* delete_min(Node* x) { 
    return merges(x->ch); 
}
```

