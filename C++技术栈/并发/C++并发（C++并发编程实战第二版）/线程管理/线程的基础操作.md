# 启动线程

简单的说，使用C++线程库启动线程，就是构造`std::thread`对象。



- 传递函数：

  ```C++
  #include <iostream>
  #include <thread>
  
  void do_some_work(){
      std::cout << "hello" << std::endl;
  }
  
  int main(){
  	std::thread my_thread(do_some_work);
      my_thread.join();
  }
  ```

- 传递函数对象：

  ```C++
  #include <iostream>
  #include <thread>
  
  class background_task {
  public:
  	void operator()() const {
  		std::cout << "hello" << std::endl;
  	}
  };
  
  int main() {
  	background_task f;
  
  	std::thread t(f);
  	t.join();
  }
  ```

  >提供的函数对象，将被复制到新线程的存储空间。

  > 需要注意：当传递临时对象时，C++编译器会将其解析为函数声明，而非对象的定义。
  >
  > ```C++
  > std::thread my_thread(background_task());
  > ```
  >
  > 相当于声明了一个函数：
  >
  > - 函数名为：my_thread
  > - 返回类型为：std::thread
  > - 形参为：一个函数指针（指向没有参数，返回类型为background_task对象的函数）
  >
  > 解决方案：
  >
  > - 多添加一个括号：
  >
  >   ```C++
  >   std::thread my_thread((background_task()));
  >   ```
  >
  > - 使用初始化列表：
  >
  >   ```C++
  >   std::thread my_thread{background_task()};
  >   ```

- 传递Lambda表达式：

  ```C++
  int main() {
  	std::thread t([]{
  		std::cout << "hello" << std::endl;
  	});
  
  	t.join();
  }
  ```

  



# 确保线程所访问数据的有效性

函数已经返回，线程依旧访问局部变量：

```C++
struct func
{
	int& i;
	func(int& i_) : i(i_) {}
	void operator() ()
	{
		for (unsigned j = 0; j < 1000000; ++j)
		{
			do_something(i);	// 1 潜在访问隐患：空引用
		}
	}
};
void oops()
{
	int some_local_state = 0;
	func my_func(some_local_state);
	std::thread my_thread(my_func);
	my_thread.detach();			// 2 不等待线程结束
}								// 3 新线程可能还在运行
```

在该代码中，已经决定不等待线程(使用了detach()②)，所以当oops()函数执行完成时③，线程中的函数可能还在运行。

如果线程还在运行，就会去调用do_something(i)①，这时就会访问已经销毁的变量。  这将导致未定义的行为。

|             主线程              |                            新线程                            |
| :-----------------------------: | :----------------------------------------------------------: |
| 使用some_local_state构造my_func |                                                              |
|       开启新线程my_thread       |                                                              |
|              启动               |                                                              |
|      调用func::operator()       |                                                              |
|         将my_thread分离         | 执行func::operator();可能会在do_something中调用some_local_state的引用 |
|      销毁some_local_state       |                           持续运行                           |
|          退出oops函数           | 持续执行func::operator()；可能会在do_something中调用 some_local_state的引用 --> 导致未定义行为 |



<font color="red">处理方案：将数据，复制到线程中</font>。

> ### 💡
>
> 不要使用，访问局部变量的函数，创建线程对象。



# 等待线程结束

2.1.2



