# 本章内容

- 共享问题
- synchronized
- 线程安全分析
- Monitor
- wait/notify
- 线程状态转换
- 活跃性
- Lock



# 共享带来的问题

## 经典的线程不安全案例

```java
@Slf4j
public class Test17 {

    public static int counter =0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            for(int i = 0;i<5000;i++){
                counter++;
            }
        },"t1");

        Thread t2 = new Thread(() -> {
            for(int i = 0;i<5000;i++){
                counter--;
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        log.debug("{}",counter);
    }
}
```

会发现，counter的运行结果大概率不为0



## 问题分析

在Java中，***对静态变量的自增、自减，并非原子操作***：

- 自增：如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：

  ```java
  getstatic i // 获取静态变量i的值
  iconst_1 // 准备常量1
  iadd // 自增
  putstatic i // 将修改后的值存入静态变量i
  ```

- 自减：

  ```java
  getstatic i // 获取静态变量i的值
  iconst_1 // 准备常量1
  isub // 自减
  putstatic i // 将修改后的值存入静态变量i
  ```



对应的Java内存模型如下，对于静态变量的自增、自减，***需要在主存和工作内存中进行数据交换***：

<img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420162717448.png" alt="image-20220420162717448" style="zoom: 50%;" />



如果是单线程的情况，上述的代码将顺序执行，不会导致错误：

<img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420162936884.png" alt="image-20220420162936884" style="zoom: 67%;" />



但在多线程的情况下，上述的代码可能交错运行，例如：

- 出错负数的情况：

  <img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420163027284.png" alt="image-20220420163027284" style="zoom: 67%;" />

- 出现正数的情况：

  <img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420163045405.png" alt="image-20220420163045405" style="zoom:67%;" />



## **临界区** **Critical Section**

- 一个程序运行多个线程本身是没有问题的

- 问题出在多个线程访问**共享资源**
  - 多个线程读**共享资源**其实也没有问题
  - 在多个线程对**共享资源**读写操作时发生指令交错，就会出现问题

- *一段代码块内如果存在对**共享资源**的多线程读写操作，称这段代码块为**临界区***。例如：

  ```java
  static int counter = 0;
  
  static void increment() 
      // 临界区
  { 
      counter++; 
  }
  
  static void decrement() 
      // 临界区
  { 
      counter--; 
  }
  ```

  

## **竞态条件** **Race Condition**

多个线程在临界区内执行，由于代码的**执行序列不同**而导致结果无法预测，称之为发生了**竞态条件**

https://www.bilibili.com/video/BV16J411h7Rd?p=53



# synchronized

## 应用之“互斥”

为了避免临界区的竞态条件发生，有多种手段可以达到目的：

- 阻塞式的解决方案：synchronized，Lock
- 非阻塞式的解决方案：原子变量



本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【***对象锁***】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换



>**注意**，虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：
>
>- 互斥：保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
>- 同步：由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点



## synchronized语法

```java
synchronized(对象){
    临界区
}
```



- 若对象锁已被某个线程占用，其余线程将发生上下文切换，进入阻塞状态；
- 若某个线程执行完synchronized{}块内的代码，***其将释放对象锁，并唤醒阻塞进程***。



注意，若某个线程获取了对象锁，***即便其时间片到而下处理机，也不会释放对象锁***。



## 面向过程的解决方案

例如：

```java
@Slf4j
public class Test18 {

    public static int counter =0;
    public static final Object room = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            for(int i = 0;i<5000;i++){
                synchronized (room){
                    counter++;
                }
            }
        },"t1");

        Thread t2 = new Thread(() -> {
            for(int i = 0;i<5000;i++){
                synchronized (room){
                    counter--;
                }
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        log.debug("{}",counter);
    }
}
```



## 面向对象的解决方案

```java
@Slf4j
public class Room {
    private int counter = 0;

    public void increment(){
        synchronized (this){
            counter++;
        }
    }

    public void decrement(){
        synchronized (this){
            counter--;
        }
    }

    public int getCounter() {
        synchronized (this){
            return counter;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Room room = new Room();

        Thread t1 = new Thread(()->{
            for (int i=0;i<5000;i++){
                room.increment();
            }
        },"t1");

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                room.decrement();
            }
        }, "t2");

        t1.start();
        t2.start();

        t1.join();;
        t2.join();

        log.debug("{}",room.getCounter());
    }
}
```



## synchronized方法

- 成员方法上的synchronized：

  ```java
  public synchronized void test() {
  
  }
  
  //等价于
  public void test() {
      synchronized(this) {
  
      }
  }
  
  ```

  

- 静态方法上的synchronized：

  ```java
  public synchronized static void test() {
  }
  
  //等价于
  public static void test() {
      synchronized(Test.class) {
  
      }
  }
  ```



# 变量的线程安全分析

https://www.bilibili.com/video/BV16J411h7Rd?p=63



