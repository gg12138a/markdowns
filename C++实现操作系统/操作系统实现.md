# 相关资料

- [视频链接](https://www.bilibili.com/video/BV1RX4y157CM?spm_id_from=333.337.search-card.all.click)

- http://wyoos.org



- [Expanded Main Page - OSDev Wiki](https://wiki.osdev.org/Expanded_Main_Page)
- [OSDev Wiki CN - osdev (foofun.cn)](http://osdev.foofun.cn/index.php?title=OSDev_Wiki_CN)



# 解惑

## 软件是如何访问硬件的

方式有两种：

1. 将某个外设的内存映射到一定范围的地址空间中， CPU 通过地址总线访问该内存区域时会落到外设的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存。

   如显卡。显卡是显示器的适配器， CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端 1MB 的0XB8000～0XBFFFF。 CPU 访问这片内存就是访问显存，住这片内存上写字节便是往屏幕上打印内容。

2. 外设是通过 IO 接口与 CPU 通信的， CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递给另一端的外设，也就是说， CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口。

   - 如何访问到 IO 接口呢？

     IO 接口上面有一些寄存器，访问 IO 接口本质上就是访问这些寄存器，这些寄存器就是人们常说的端口。这些端口是人家 IO 接口给咱们提供的接口。人家接口电路也有自己的思维（系统），看到寄存器中写了什么就做出相应的反应。



## 内存的分段访问

CPU 采用 “段基址＋段内偏移地址”的形式访问内存，就需要专门提供**段基址寄存器**，这些是 cs ds es 。程序中需要用到哪块内存，只要先加载合适的段到段基址寄存器中，再给出相对于该段基址的偏移地址便可， CPU 中的地址单元会将这两个地址相加后的结果用于内存访问，送上地址总线。



## 代码段与数据段

- x86 平台的处理器是必须要用分段机制访问内存的，正因为如此，处理器才提供了段寄存器，用来指定待访 问的内存段起始地址。

- 我们这里讨论的程序代码中的段（用 section segment 来定义的段，不同汇编编译器提供的关键字有所区别，功能是一样的）和内存访问机制中的段本质上是一回事。在硬件的内存访问机制中，处理器要用硬件——段寄存器，指向软件一一程序代码中用 section 或 segment 以软件形式所定义的内存段。

- 一般的高级语言不允许程序员自己将代码分成各种各样的段，这是因为其所用的编译器是针对某个操作系统编写的，该操作系统采用的是平坦模型，所以该编译器要编译出适合此操作系统加载运行的程序。
- 由于处理器支持了具有分页机制的虚拟内存，操作系统也采用了分页模型，因此**编译器会将程序按内容分成代码段和数据段**，如编译器 gcc 会把 C 语言写出的程序划分成代码段、数据段、栈段、.bss 段、堆等部分。这会由操作系统将编译器编译出来的用户程序中的各个段分配到不同的物理内存上。
  - 为了让程序内指令接连不断地执行，要把指令全部排在 起，形成一片连续的指令区域，这就是代码段。
  - 把数据连续地并排在一起存储形成的段，即为数据段。
  - 具有全局属性的但又未初始化的数据放在 bss 段



将数据和代码，分开的好处：

1. 为它们赋予不同的属性

   例如数据本身是需要修改的，所以数据就需要有可写的属性，不让数据段可写，那程序根本就无法执行啦。程序中的代码是不能被更改的，这样就要求代码段具备只读的属性。

2. 提供CPU内部缓存的命中率

3. 节省内存



## 段的保护是如何实现的

1. 编译器负责**挑选**出数据具备的属性，从而根据属性将程序片段分类，比如，划分出了只读属性的代码段和可写属性的数据段。

2. 操作系统通过设置 **GDT 全局描述符表**来构建段描述符，在段描述符中指定段的位置、大小及属性（包括 S 字段和 TYPE 字段）。

   也就是说，**操作系统**认为代码应该是只读的，所以给用来指向代码段的那个段描述符设置了只读的属性，这才是***真正给段添加属性的地方***。

3. CPU 中的段寄存器提前被操作系统赋予相应的选择子（后面章节会讲什么是选择子，暂时将其 理解为相当于段基址〉，从而确定了指向的段。**在执行指令时，会根据该段的属性来判断指令的行为，若有返回则发出异常**。

> 总之，编译器、操作系统、CPU 三个配合在一起，才能对程序进行保护，检测出指令的违规行为。



## 物理地址、逻辑地址、有效地址、线性地址、虚拟地址

![image-20220609235057433](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0.assets/image-20220609235057433.png)

- 实模式下：

  段基址 + 段内偏移地址 = 物理地址

- 保护模式下：

  段基址 + 段内偏移地址 = 线性地址

  段基址称作为“选择子”，本质是一个索引，通过本索引便能在 GDT 中找到相应的段描述符（描述符记录了段的信息（包含段基址））。

  - 若未开启地址分页功能：

    线性地址将被当作物理地址使用

  - 若开启：

    线性地址也称作虚拟地址，经过CPU 页部件转换成物理地址

> 参见《操作系统真象还原》 P11



## 段重叠现象

![image-20220609235706903](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0.assets/image-20220609235706903.png)

即：虽然两个段的段基址不同，其仍有可能访问到同一片地址空间



## sreg 段寄存器

CPU内部的段寄存器（Segment reg）如下：

- CS——代码段寄存器（Code Segment Register），其值为代码段的段基值。

- DS——数据段寄存器（Data Segment Register），其值为数据段的段基值。

- ES——附加段寄存器（Extra Segment Register），其值为附件数据段的段基值。

  此段寄存器的用途不像其他 sreg 那样固定，可以另作他用。

- FS一一附加段寄存器（ Extra Segment Register ），其值为附加数据段的段基值，同上，用途不固定， 使用上灵活机动。

- GS一一附加段寄存器（ Extra Segment Register ），其值为附加数据段的段基值。
- SS一一堆栈段寄存器（ Stack Segment Register ），其值为堆栈段的段值。



32 CPU 有两种不同的工作模式：

- 实模式：

  在实模式下， CS DS ES SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为 “段基值：段内偏移量”的形式。

- 保护模式：

  装入段寄存器的不再是段地址，而是“段选择子” (Selector),  当然，选择子也是数值，其依然为 16 位宽度。

>每种模式下，段寄存器中值的意义是不同的，但不管其为何值，在段寄存器中所表达的都是指向的段 在哪里。

>可见，在 32 CPU 中， sreg 无论是工作在 16 位的实模式，还是 32 位的保护模式，用的段寄存器都是同一组，并且在 32 位下的段选择子是 16 位宽度，排除了段寄存器在 32 位环境下是 32 位宽的可能。
>
>#### 💡 综上所述， sreg 都是 16 位宽。



## 大端字节序、小端字节序

> 参见《操作系统真象还原》 P19

