# 加载

> “加载”(Loading)阶段是整个”类加载“(Class Loading)过程中的一个阶段

## JVM在加载阶段的任务

在加载阶段，Java虚拟机需要完成三件事情：

1. 通过一个类的全限定名，来获取定义了此类的二进制字节流
2. 将这个字节流所代表的静态存储结构，转换为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

《Java虚拟机规范》对这三点要求并不是特别具体，留给虚拟机实现与Java应用的灵活度很高。

例如对于第一条规则，它没有知名二进制字节流必须得从某个Class文件中获取，确切的说根本没有指明要从哪里获取，如何获取。这为Java虚拟机的使用者们在加载阶段搭建出一个相对开放的舞台，例如：

- 从ZIP压缩包中获取。最终称为日后JAR、EAR、WAR格式的基础

- 从网络中获取，此场景中最典型的应用是Web Applet

- 运行时计算生成，此场景中使用最多的是动态代理技术。

    在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为”*$Proxy”的代理类的二进制字节流

- 从其他文件中生成，典型场景是JSP应用，将由JSP文件生成对应的Class文件

- 从数据库中读取，这种场景相对少见，例如有些中间件服务器(如SAP Netweaver)可以选择把程序安装到数据库中，来完成程序代码在集群间的分发

- 可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保证程序运行逻辑不被窥探

加载阶段结束后：

1. Java虚拟机外的二进制字节流，将会按照虚拟机所设定的格式，存储在方法区之中。

    > 方法区中的数据存储格式完全由虚拟机自行定义，《Java虚拟机规范》未作规定

2. 类型数据妥善安置在方法区之后，会在Java队中实例化一个Java.lang.Class类的对象。

    这个对象将作为程序访问方法区中的类型数据的外部接口

>加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证工作)是交叉进行的，加载阶段尚未结束，连接阶段可能已经开始。 但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序

## 非数组类型与数组类型的加载

相对于类加载过程的其他阶段，非数组类型的加载阶段(准确的说，是加载阶段中获取类的二进制字节流的动作)是开发人员可控性最强的阶段。

加载阶段，既可以使用Java虚拟机内置的引导类加载器来完成，也可以由用户自定义的类加载器完成，开发人员需要通过定义自己的类加载器，去控制字节流的获取方式(重写类加载器的findClass()方法或loadClass()方法)，实现根据自己的想法来赋予应用程序获取运行代码的动态性

但对于数组类，情况有所不同。数组类本身不通过类加载器创建，是由Java虚拟机直接在内存中动态构造的。但数组类与类加载器仍然有密切的联系：数组类的元素类型(Element Type,数组去掉**所有**维度后的类型)，最终还是要靠类加载器来实现的。

一个数组类(下面简称C)的创建过程，遵循以下规则：

- 如果数组的组件类型(Component Type,数组去掉**一个**维度后的类型)是引用类型，就采用本节中定义的加载过程去加载这个组件类型。数组C将被标识在加载该组件类型的类加载器、的类名称空间上。

- 如果数组的组件类型并非引用类型(如int[])，Java虚拟机将会把数组C标记为与引导类加载器相关

- 数组类的可访问性与它的组件类型的可访问性一致。

    如果组件类型非引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问

# 验证

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码后不会危害虚拟机自身的安全。

使用纯粹的Java代码，无法做到(诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情），如果尝试这么做，编译器将抛出异常，拒绝编译。

但是，Class文件并不是一定要由Java源码编译而来，它可以由使用包括靠键盘0和1直接在二进制编辑器中敲出Class文件在内的任何途径产生。上述代码无法做到的事情，在字节码方面是可以(在语义上)实现的。

Java虚拟机如果不检查输入的字节流，很可能会因为载入有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃。

在《Java虚拟机规范》的早期版本(1,2版)对这个阶段的检查指导是相当模糊和笼统的，规范中仅列举了一些对Class文件格式的静态和结构化的约束，要求虚拟机在验证到输入的字节流如不符合Class文件格式的约束时，抛出java.lang.VerifyError异常或其子类，但具体应当检查哪些内容、如何检查、何时进行检查等，都没有足够具体的要求和明确的说明。

2011年的《Java虚拟机规范(Java SE 7版)》中，规范中大幅增加了验证阶段的描述。从整体上看，验证阶段大致上会完成如下的四个阶段的检查动作：文件格式验证、元数据验证、字节码验证、符号引用验证

## 文件格式验证

第一阶段要验证字节流是否符号Class文件格式的规范，并且能够被当前版本的虚拟机处理。

在此阶段，可能包含下面的这些验证点：

- 是否以魔术0xCAFEBABE开头
- 主、次版本号是否在当前Java虚拟机接收范围之内
- 常量池的常量，是否有不被支持的常量类型(检查常量tag标志)
- 指向常量的各种索引值，是否有指向不存在的常量或不符合类型的常量
- CONSTANT_Utf8_info型的变量中，是否不符合UTF-8编码的数据
- Class文件中各个部分及文件本身，是否有被删除或被附加的其他信息
- ...

总而言之，该验证阶段的主要目的——保证输入的字节流能正确地解析并存储于方法区之内，格式上符号描述一个Java类型信息的要求。

该阶段的验证是基于二机制字节流进行的，只有通过该阶段的验证之后，这段字节流才会被允许进入Java虚拟机内存的方法区进行存储。

> 后面的三个验证阶段，全部是基于方法区的存储结构进行的。不会再直接读取、操作字节流

## 元数据验证

第二阶段是对字节码描述的信息，进行语义分析，以保证其描述的信息符合规范的要求。

该阶段可能包含的验证点如下：

- 这个类是否有父类(除java.lang.Object之外，所有的类应该都有父类)
- 这个类的父类，是否包含了不允许被继承的类(被final修饰的类)
- 如果这个类不是抽象类 ，是否实现类其父类或接口之中要求实现的所有方法
- 类中的字段、方法是否与父类产生矛盾（如覆盖父类的final字段，或不符合规则的方法重载）
- ...

第二阶段的主要目的——对类的元数据信息进行语义校验，保证不存在与规范中的定义相悖的元数据信息。

## 字节码验证

第三个阶段是整个验证阶段中最复杂的一个阶段，主要目的是通过数据流分析与控制流分析，确保程序语义是合法的、符合逻辑的。

在完成第二个阶段对元数据信息的数据类型校验之后，该阶段将要对类的方法体(Class文件中的Code属性)进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。如：

- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。例如不会出现类似于“在操作数栈中放置了一个int类型的数据，使用时却按照long类型来加载入本地变量表中”的情况
- 保证任何跳转指令，都不会跳转到方法体意外的字节码指令上
- 保证方法体的类型转换总是有效的。例如可以把一个子类对象赋值给父类数据类型，这是合法安全的；但如果把父类对象赋值给子类数据类型，甚至是赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险不合法的。
- ...

如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；

但即便一个方法体通过了字节码验证，也不能保证它一定就是安全的。通过程序去校验程序逻辑是无法做到绝对准确的，不可能用程序来准确判定一段程序是否存在BUG

为了避免过多的执行时间消耗在字节码验证阶段，在JDK6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助工作挪到Javac编译器里进行：

给方法体Code属性的属性表中，新增了一项名为“StackMapTable”的新属性。该项属性描述了方法体所有的基本块(Basic Block,指按照控制流划分的代码块)开始时，本地变量表和操作栈应有的状态。在字节码验证阶段，Java虚拟机就不再需要根据程序推到这些状态的合法性，只需要检查StackMapTab属性中的记录是否合法即可。

这样就使将字节码验证的类型推导，转变为类型检查，从而节省了大量校验时间。

但理论上StackMapTable属性存在错误或篡改的可能，虚拟机设计者们需要仔细考虑这样的问题：是否有可能在恶意篡改Code属性的同时，也生成相应的StackMapTable属性来骗过虚拟机的类型校验

## 符号引用验证

最后一个阶段的校验行为，发生在虚拟机将符合引用，转换为直接引用的时候。这个转换动作将在连接的第三个阶段——[解析](https://www.notion.so/efd367c7540b487a9c6c2db00a733417)阶段中发生。

符号引用验证可以看作是对类自身以外(常量池中的各种符合引用)的各类信息，进行匹配性校验。

通俗的说就是，该类是否缺少或被禁止访问它依赖的某些外部类、方法、字段等资源。

本阶段通常需要校验下列内容：

- 符号引用中，通过字符串描述的全限定名，是否能够找到对应的类
- 在指定类中，是否存在符合方法的字段描述及简单名称所描述的方法和字段
- 符号引用中的类、字段、方法的可见性(private,protected,public,package)是否可以被当前类访问
- ...

符号引用验证的主要目的——确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机讲抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如：java.lang.IllegalAccessError,java.langNoSuchFieldError,java.lang.NoSuchMethodError等

验证阶段对于虚拟机的类加载机制来说，是一个非常重要、但却不是必须执行的阶段。

如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间

# 准备

准备阶段，是正式将类中定义的变量(即**static变量**)分配内存并设置类变量的初始值的阶段。

- 这些变量所使用的内存都应当在方法区中进行分配，但方法区本身是一个逻辑上的概念。

    - 在JDK7及以前，HotSpot使用永久代来实现方法区时，是完全符合这个逻辑概念的
    - 但在JDK8及之后，类变量会随着Class对象一起存放在Java堆中。此时的”类变量在方法区”就完全是一种逻辑概念的表达了

- 注意，关于此处的初始值

    - 在“通常情况”是对应数据类型的零值

        例如存在如下的类变量定义：`public static int value = 123;`那么变量value在准备阶段之后的初始值将为0而非123；因为此时尚未开始执行任何Java方法，而把value赋值为123的putstaic指令是程序被编译后，存放于类构造器<clinit>()方法之中，即把value初始化为123的动作要到类的初始化阶段才会执行。

    - “特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段变量值就会被初始化为所指定的初始值

        例如存在如下常量定义：`public static**final**int value =123;`编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置，将value赋值为123

# 解析

解析阶段是Java虚拟机，将常量池内的符号引用，替换为直接引用的过程。

- 符号引用(Symbolic References)：

    符合引用以一组符号来描述所引用的目标，符号可以是任何形式的字面值，只要使用时能无歧义地定位到目标即可。

    符号引用与虚拟机实现的内存布局无关，引用的目标不一定是已经加载到虚拟机内存当中的内容

    虽然各虚拟机实现的内存布局各不相同，但它们能接受的符号引用必须都是一致的。因为符号引用的字面值形式，明确规定在《Java虚拟机规范》的Class文件格式中

- 直接引用(Direct References)：

    直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。

    直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上，翻译出来的直接引用一般不会相同。

    如果有了直接引用，就意味着引用的目标必然已经在虚拟机的内存中存在

解析动作，主要针对以下7类符号引用进行：

- 类：

- 接口

- 字段

- 类方法

- 接口方法

- 方法类型

- 方法句柄

- 调用点限定符

- 分别对应着8种常量类型：

    ![Untitled(9)](%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B.assets/Untitled(9)-16473500234055.png)

## 类与接口的解析

假设当前代码所处的类为D，若要把一个从未解析过的符号引用N解析为一个类或接口C，那么虚拟机完成整个解析的过程，需要包含以下三个步骤：

1. 如果C不是一个数组类型，虚拟机会把代表N的全限定名，传递给D的类加载器让其去加载类C。

    在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他类的加载动作。

    一旦加载过程出现了任何异常，解析过程就宣告失败

2. 如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符将会是类似”[Ljava/lang/Integer”的形式，那么将会先按照第一条规则加载数组的元素类型(Integer)，接着由虚拟机生成一个代表该数组维度和元素的数组对象

3. 如果上面两部没有出现任何异常，那么C在虚拟机中实际上已经称为一个有效的类或接口了。但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常

## 字段解析

要解析一个未被解析的字符符号引用，首先会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。

如果在解析这个类或接口的符号引用时出现任何异常，都会导致字段符合引用解析的失败；

如果解析成功完成，那把这个字段所属的类或接口用C表示，《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索：

1. 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束
2. 否则，如果在C中实现了接口，将会按照继承关系，从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述都与目标相匹配的字段，则返回这个字段的直接引用，查找结束
3. 否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述都与目标想匹配的字段，则返回这个字段的直接引用，查找结束
4. 否则，查找失败，抛出java.lang.NoSuchFieldError异常

如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，讲抛出java.lang.IllegalAccessError异常

以上的解析规则，能够确保Java虚拟机获得字段唯一的解析结果。

但在实际情况中，Javac编译器往往会采取比上述规范更加严格的一些约束：

譬如：有一个同名字段，同时出现某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则扔是可以唯一确定的字段。

但Javac编译器却可能直接拒绝将其编译Class文件。

- 如Oracle公司的javac编译器，将提示”The field Sub.A is ambiguous”，并且拒绝编译此段代码

    ```java
    public class FieldResolution {
    
        interface Interface0{
            int A = 0;
        }
    
        interface Interface1 extends Interface0{
            int A = 1;
        }
    
        interface Interface2{
            int A = 2;
        }
    
        static class Parent implements Interface1{
            public static int A = 3;
        }
    
        static class Sub extends Parent implements Interface2{
            public static int A = 4;
        }
    
        public static void main(String[] args) {
            System.out.println(Sub.A);
        }
    }
    ```

## 方法解析(类)

方法解析的第一个步骤与字段解析一样，也是需要先解析出方发表的class_index项中索引的方法所属的方法或接口的符号引用。如果解析成功，那么我们依然用C来表示这个**类**，接下来虚拟机讲会按照如下步骤进行后续的方法搜索：

1. 由于Class文件格式中，类的方法和接口的方法的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常
2. 如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则直接返回这个方法的引用，查找结束
3. 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则直接返回这个方法的引用，查找结束
4. 否则，在类C实现的接口列表及他们的父接口中递归查找，是否具有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常
5. 否则，宣告方法查找结束，抛出java.lang.NoSuchMethodError异常

最后，如果查找成功返回了直接引用，将会对这个方法进行权限验证，如果方法不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常

## 接口方法解析(接口)

接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个**接口**，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：

1. 与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而非接口，将直接抛出java.lang.IncompatibleClassChangeError异常

2. 否则，在接口C中查找是否具有简单名称和描述都与目标方法相匹配的方法，如果有则返回这个方法的直接引用，查找结束

3. 否则，在接口C的父接口中递归查找，直到java.lang.Object类，如果有则返回这个方法的直接引用，查找结束

    注意，由于Java的接口允许多继承(类不允许)，如果接口C的不同父接口中存在多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找。

    《Java虚拟机规范》并未明确约束应该返回哪一个接口方法，但与之前字段查找解析类似，不同发行商实现的javac编译器有可能按照更严格的约束，拒绝编译这种代码

4. 否则，宣告方法查找结束，抛出java.lang.NoSuchMethodError异常

在JDK9之前，java接口中的方法都是public的，并且没有模块化的访问约束，所以不存在访问权限的问题。但在JKD9中，增加了接口的静态私有方法，也有了模块化的访问约束，接口方法的访问有可能因访问权限控制，抛出java.lang.IllegalAccessError异常

> 接口的：
>
> - 静态方法：不能通过接口的实现类调用接口的静态方法，通过接口名称.静态方法名称()
> - 私有方法：当接口 的方法中有大量的重复代码时可以使用私有方法提取共有的代码，使得只有接口中的方法可以使用，实现类不能调用

# 初始化

类的初始化阶段，是类加载过程中的最后一个阶段。

在之前介绍的几个类加载的动作里，除在加载阶段，用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。

直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权转给应用程序

在进行准备阶段时，类变量已经赋过一次系统要求的初始零值；而在初始化阶段，则会根据程序员通过程序编写的主观计划，去初始化类变量和其他资源。

更直接的，初始化阶段就是执行类构造器<clinit>()方法的过程。

<clinit>()并不是程序员在Java代码中直接编写的方法，它是javac编译器的自动生成物。

- <clinit>()方法，是由编译器自动收集类中的所有类变量的赋值动作，和静态语句块(static{})中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。静态语句块仅能访问到定义在该语句块之前的变量；定义在它之后的变量，仅能在语句块中进行赋值，但不能访问

    - 例如：

        ```java
        public class hello {
            static {
                i=2;    //ok
                System.out.println(i); //error，非法前向引用
            }
        
            static int i = 1;
        }
        ```

        ![Untitled(8)](%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B.assets/Untitled(8)-16473498644194.png)

- <clinit>()方法，与类的构造函数(即虚拟机视角的实例构造器<init>())不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此，在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是Object

- 由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块，要优先于子类的变量赋值操作。

    - 例如：

        ```java
        public class Parent {
        
            public static int A = 1;
            static {
                A=2;
            }
        
            static class Sub extends Parent{
                public static int B = A;
            }
        
            public static void main(String[] args) {
                System.out.println(Sub.B);  //2
            }
        }
        ```

- <clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态代码块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法

- 接口中虽然不能使用静态代码块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也不会执行接口的<clinit>()方法

- Java虚拟机必须保证一个类的<clinit>()方法在多线程环境下正确地加锁同步，如果多个线程同事去初始化一个类，那么只会有一个线程去执行类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。

    如果一个类的<clinit>()方法中有耗时很长的操作，那么就可能造成多个线程阻塞。

    - 例如：

        ```java
        public class DeadLoopClass {
            static {
                if(true){
                    System.out.println(Thread.currentThread()+"init DeadLoopClass");
                    while (true){}
                }
            }
        }
        ```

        ```java
        public class Test {
        
            public static void main(String[] args) {
                Runnable script = new Runnable() {
                    @Override
                    public void run() {
                        System.out.println(Thread.currentThread()+"start");
                        DeadLoopClass deadLoopClass = new DeadLoopClass();
                        System.out.println(Thread.currentThread()+"run over");
                    }
                };
        
                Thread thread1 = new Thread(script);
                Thread thread2 = new Thread(script);
                thread1.start();
                thread2.start();
                //Thread[Thread-1,5,main]start
                //Thread[Thread-0,5,main]start
                //Thread[Thread-1,5,main]init DeadLoopClass
        
        				//即一个线程始终在执行<clinit>()方法，另一个线程始终在阻塞等待
            }
        }
        ```

[]()