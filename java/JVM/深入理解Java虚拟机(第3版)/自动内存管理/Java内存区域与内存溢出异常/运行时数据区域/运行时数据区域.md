Java虚拟机在执行Java程序的过程中，会把它所管理的内存划分为若干个不同的数据区域。

每个区域有各自的用途，创建和销毁的时间。

有的区域随着虚拟机进程的启动而一直存在，

有的区域则是依赖用户线程的启动和结束而建立和销毁。

根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包含以下几个运行时数据区域：

![Untitled(3)](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.assets/Untitled(3).png)



# 线程隔离的数据区

## 程序计数器(Program Counter Register)

程序计数器是一块较小的内存空间，可以看作是**当前线程**所执行的**字节码**的行号指示器。

在Java虚拟机的概念模型里，字节码解释器的工作即为：

通过改变此计数器的值，来选取下一条需要执行的字节码指令。

程序计数器是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖于程序计数器来完成。

Java虚拟机的多线程，是通过线程轮流切换、分配处理器执行时间的方式实现的。

> 即在任何一个确定的时刻，一个单核处理器(或多核处理器的一个内核)，都只会执行一条线程。

为了在线程切换后能恢复到正确的执行位置，每个线程都需要一个单独的程序计数器。

各条线程之间的计数器互不影响，独立存储。这类内存区域称为“线程私有”的内存

注意：

- 如果线程正在执行的是Java方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址
- 如果正在执行的是本地(Native)方法，那么计数器的值应为空(Undefined)

此内存区域，是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域

## Java虚拟机栈(Java Virtual Machine Stack)

与程序计数器相同，Java虚拟机栈也是线程私有的，与线程具有相同的生命周期。

虚拟机栈描述的是：Java方法执行的线程内存模型。

每个方法被执行的时候，Java虚拟机会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数帧、动态连接、方法出口等信息。

- 局部变量表：

    存放了编译期可知的：

    - 各种Java虚拟机基本数据类型(boolean,byte,char,short,int,float,long,double)
    - 对象引用(reference类型，可能是指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄，或者其他与此对象相关的位置）
    - returnAddress类型（执行一条字节码指令的地址）

    这些数据类型在局部变量表中的存储空间，以局部变量槽(Slot)来表示。其中64位长度的long和double类型会占用两个变量槽，其余数据类型只占用一个。

    局部变量表所需的内存空间大小在编译期间完成分配。当进入一个方法时，此方法需要在栈帧中为局部变量分配的空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

    > 注意，此处的大小指变量槽的数量。一个变量槽占用多少比特的内存空间是由虚拟机自行决定的。

每一个方法被调用直至执行完毕的过程，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

在《Java虚拟机规范》中，对此内存区域规定了两类异常情况：

- 线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常；
- 虽然Java虚拟机栈容量可以动态拓展，但在栈拓展时无法申请到足够的内存，抛出OutOfMemoryError异常

## 本地方法栈(Native Method Stacks)

与虚拟机栈发挥非常类似的作用。但区别是：

- 虚拟机栈为虚拟机执行Java方法(即字节码)服务
- 本地方法栈为虚拟机使用的本地(Natvie)方法服务

《Java虚拟机规范》对本地方法栈中，方法使用的语言、使用方式、数据结构并没有任何强制规定。因此具体的虚拟机可以根据需要自由实现它。

> 甚至有的Java虚拟机（如HotSpot直接将本地方法栈和虚拟机栈合二为一）

与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈拓展失败时，分别抛出StackOverflowError和OutOfMemoryError异常

# 由所有线程共享的数据区

## Java堆(Java Heap)

对于Java应用程序来说，Java堆是虚拟机所管理的内存中最大的一块。

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。

此区域的唯一目的是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。

Java堆是垃圾收集器管理的内存区域，一些资料也将称作“GC堆”(Garbage Collected Heap)。

从回收内存的角度看，由于现代垃圾收集器大部分是基于分代收集理论设计的，Java堆经常会出现”新生代”“老年代”“永生代”“Eden空间”“From Survivor空间”“To Survivor空间”等名称，但这并非《Java虚拟机规范》里对Java堆的进一步细致划分。

<aside> 💡 将Java堆细分的目的，只是为了更好地回收内存

</aside>

根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。但对于大对象（典型的如数组对象），多数虚拟机出于实现简单，存储高效的角度，很可能要求分配连续的内存空间

> 类似于使用磁盘空间存储文件，并不要求每个文件都连续存放。

Java堆既可以被实现为固定大小的，也可以是可拓展的。

不过主流的Java虚拟机都是按照可拓展来实现的(通过参数 -Xmx 和 -Xms 设定)。

如果在Java堆中没有内存完成实例分配，并且堆也无法再拓展时，Java虚拟机将抛出OutOfMemoryError异常。

## 方法区(Method Area)

方法区与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名“非堆”(Non-Heap)，目的是与Java堆区分开来。

方法区与概念”永久代“：

尤其在JDK8之前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人将方法区称呼为”永久代“，甚至混为一谈。但本质上两者是并非等价的。

仅是因为当时的HotSpot虚拟机设计团队，选择把收集器的分代设计，拓展至方法区（或者说用永久代来实现方法区）而已。使得HotSpot的垃圾收集器能像管理Java堆一样，管理这部分内存，省去专门为方法区编写内存管理代码的工作。

对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。

原则上， 如何实现方法去属于虚拟机实现细节，不受《Java虚拟机规范》管束，不要求统一。

但回头来看，当年使用永久代来实现方法区的设计，导致Java应用更容易遇到内存溢出的问题（永久代有 -XX:MaxPermSize的上限，即便不设置也有默认大小。而J9和JRockit只要没有触碰到进程可用内存的上限(如32位系统的4GB)，就不会有问题。）

<aside> 💡 最终HotSpot改用与JRockit、J9一样的方式，采用在本地内存中实现的元空间（Metaspace）来实现方法区

</aside>

《Java虚拟机规范》对方法区的约束是非常宽松的：

除和Java堆一样不需要连续的内存、可以选择固定大小或可拓展外，

甚至还可以选择不实现垃圾收集。

根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

### 运行时常量池(Runtime Constant Pool)

运行时常量池，是方法区的一部分。

Class文件中：

- 除了有类的版本、字段、方法、接口等描述信息外；

- 还有一项信息是常量池表(Constant Pool Table)。用于存放编译期生成的，各种字面值与符号引用。

    常量池表的内容，将在类加载后，存放到方法区的运行时常量池。

运行时常量池，相对于Class文件常量池的一个重要特征是具备动态性。

Java语言并不要求常量一定要在编译期才能产生。也就是说，并非预置入Class文件中常量池的内存才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中。

> 典型的有：String类的intern()方法

既然运行时常量池是方法区的一个部分，自然受到方法区内存的限制。当常量池无法申请到新的内存时，将抛出OutOfMemoryError异常。

# 直接内存(Direct Memory)

直接内存，既不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。

但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。

在JDK1.4中，新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式。

它可以使用Native函数库，直接分配堆外内存，然后通过在一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用，来进行操作。

这样能在一些场景中，显著提高性能。因为避免了在Java堆和Native 堆中来回复制数据。

显然，本地直接内存的分配，不会受到Java堆大小的限制。但既然是内存，就肯定会受到本机总内存(包括物理内存、SWAP分区或者分页文件)大小以及处理器寻址空间的限制。

一些服务器管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx 等参数信息，但却经常忽略掉直接内存，使得各个区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态拓展时出现OutOfMemoryError异常。