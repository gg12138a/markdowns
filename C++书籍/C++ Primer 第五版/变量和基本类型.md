# C++是静态强类型语言

- 静态语言：

  变量类型的检查，在编译期间。

- 强类型语言：

  变量类型被定义后，不能自动转换。需要进行强制类型转换。





# 内置类型

## 算数类型

|    类型     |      含义      |   最小尺寸   |
| :---------: | :------------: | :----------: |
|    bool     |    布尔类型    |    未定义    |
|    char     |      字符      |     8bit     |
|   wchar_t   |     宽字符     |    16bit     |
|  char16_t   |  Unicode字符   |    16bit     |
|  char32_t   |  Unicode字符   |    32bit     |
|    short    |     短整型     |    16bit     |
|     int     |      整型      |    16bit     |
|    long     |     长整型     |    32bit     |
|  long long  |     长整型     |    64bit     |
|    float    |  单精度浮点数  | 6位有效数字  |
|   double    |  双精度浮点数  | 10位有效数字 |
| long double | 拓展精度浮点数 | 10位有效数字 |



> 注意：
>
> char类型，存在signed char 和 unsigned char共三种。
>
> > 不同于数字类型，char的默认，不一定是signed的（取决于编译器）。



## 数值类型的自动类型转换

```c++
bool b = 42;    // b为真
    int i = b;      // i为1
    i = 3.14;       // i为3
    double pi = i;  // pi为3.0
    unsigned char c = -1;   // 假设char占8bit，c为255
    signed  char c2 = 256;  // 假设char占8bit，c2的值undefined
```



- 对无符号类型，给它一个超出表示范围的值：

  若该无符号类型8bit（表示范围0~255)，赋x，结果为x mod 256。

- 对**有符号类型**，给它一个**超出表示范围的值**：

  结果将是**undefined**。

  > 程序此时可能：
  >
  > - 继续工作
  > - 崩溃
  > - 产生垃圾数据



## 无符号类型参与运算的表达式

> signed数，会自动转型为unsigned数。
>
> - 负数转无符号数：对字节，按照补码进行解释。
>
>   

- unsigned类型，参与加法：

  有符号数，将自动转型为无符号数，表达式结果类型为无符号类型。

  结果为无符号数的模，加该负数。例如：-42转为4字节无符号数，结果为4294967296 - 42 = 4294967264。

- unsigned类型，参与减法：

  你必须保证，逻辑上的结果值不能为负数（因为采用补码正数对字节数进行解释）。

  一个死循环如下：

  ```C++
  for (unsigend u = 10; u>=0 ; u--){};
  // 假设int类型为32位，当u=0时，--u的结果为4294967295
  ```

  



## 字面值常量

- 整形和浮点型字面值

- 字符字面值

- 字符串字面值：实际上是由常量字符组成的数组

  > 若两个字符串字面值紧邻，且仅由空格，缩进或换行符分隔，则它们实际上是一个字符串字面值。



## 指定字面值的类型

- 字符和字符串字面值：

  | 前缀 |             含义              |   类型   |
  | :--: | :---------------------------: | :------: |
  |  u   |        Unicode 16字符         | char16_t |
  |  U   |        Unicode 32字符         | char32_t |
  |  L   |            宽字符             | wchar_t  |
  |  u8  | UTF-8<br />仅用于字符串字面值 |   char   |

- 整形字面值：

  |   后缀   |           最小匹配类型           |
  | :------: | :------------------------------: |
  |  u or U  | unsigned<br />表明使用无符号类型 |
  |  l or L  |               long               |
  | ll or LL |            long long             |

- 浮点型字面值：

  |  后缀  |    类型     |
  | :----: | :---------: |
  | f or F |    float    |
  | l or L | long double |



# 变量

- 变量提供，一个具名的、可供程序操作的存储空间。
- 变量类型，决定了：
  - 该变量所占的内存空间大小与布局方式
  - 该空间能存储的值的范围
  - 变量能参与的运算



## 初始化与赋值

- 初始化：

  创建变量的同时，为其赋予一个初始值。

- 赋值：

  将变量的当前值擦除，使用一个新值来替代。



## 初始化的4种写法（列表初始化）

定义一个名为 units_sold 的 int 变量，并初始化为0：

- `int units_sold = 0;`
- `int units_sold = {0};`
- `int units_sold{0};`（大括号）
- `int units_sold(0);`（圆括号）



列表初始化的特点：

- 若初始值存在丢失信息的风险时，编译器将报错：

  ```C++
  long double ld = 3.1415926536;
  int a{ld}, b = {ld};	// 错误：转换未执行，因为存在丢失信息的风险
  int c(ld), d = ld;		// 正确：转换执行，但丢失了信息
  ```

  



## 默认初始化

- 若变量在定义时未指定初始值，则执行默认初始化。

  - 内置类型：

    - 定义于任何函数之外，初始化为0

  - 类对象：

    由该类决定初始化的方式，**决定是否允许不经初始化定义就定义对象**。



## 声明与定义

- 为了支持**分离式编译机制**，C++允许将程序分隔为若干个文件，每个文件可独立编译。

- 声明：

  - 使得名字为程序所知。一个文件若想使用别处定义的名字，则必须包含对那个名字的声明。

  - 变量声明，规定了变量的类型与名字。
  - 例如：`extern int i;`

- 定义：

  - 负责创建与名字关联的实体。
  - 变量定义，规定了变量的类型与名字，**申请存储空间，并可能为变量赋初值**。

> 同一个变量，仅可被定义一次，但允许被声明多次。





## 标识符与变量命名规范

- 标识符规则：字母、数字、下划线。以字母或下划线开头。



规范：

- 不要连续出现两个下划线
- 不要以`_紧邻大写字母`开头
- 函数体外的标识符，不要以`_`开头

- 变量名小写。studentLoan 或 student_loan
- 类名以大写开头。Sales_item 或 SalesItem



## 名字的作用域

- 在程序种，**名字**会指向一个特定的实体：**变量、函数、类型等**。
- 名字的作用域：
  - 始于：名字的**声明语句**。
  - 结束于：作用域末端标识符（花括号）



- 嵌套作用域：

  局部变量，会隐藏全局同名变量。

  > 此情况下，使用作用域运算符`::`，从而使用全局变量。





# 复合类型

一条声明语句的组成：

`基本数据类型` + `声明符`。

- 声明符：命名了一个变量，并指定该变量为与基本数据类型有关的某种类型。

  > 一般情况下，声明符就是变量名。



## 引用

引用，为对象起了另外一个名字。例如：

```C++
int ival = 1024;
int &refVal = ival;
```



- 引用无法绑定另一个对象，**必须进行初始化**。

  > 引用即别名，其本身并非对象，不能定义引用的引用。

- **引用必须绑定在对象上**，而不能绑定字面值或某个表达式的结算结果。

- **引用的类型，必须与待绑定的对象严格匹配**。

  > 例外：
  >
  > - 指向const的引用，可绑定非常量的对象
  >
  > - [对const的引用，可以绑定其他类型](#对const的引用可以绑定其他类型)（因为绑定的是临时对象）
  >
  >   PDF：P55
  >
  > - P534



## 指针

- 指针，是“指向(point to)”另外一个类型的复合类型。

- 指针与引用的区别：

  - 指针本身是一个对象。

  - 指针可以指向另一个对象。

    > 引用非对象，没有实际地址。不能定义指向引用的指针。

  - 指针不强制在定义时赋初值。

- 指针的类型，要与它指向的对象严格匹配。

  > 例外：
  >
  > - [指向常量的指针](指向常量的指针)，可以指向非常量对象
  >
  >   PDF：P56
  >
  > - P534



### 空指针

- C++11标准：使用**字面值 nullptr** 来初始化指针。

- 将指针初始化为字面值 0

  >在过去的程序种，往往使用在头文件cstdlib中定义的，名为**NULL**的<u>预处理变量</u>，其值为0。



### void* 指针

- void*是一种特殊的指针类型，**可以存放任意类型对象的地址**。
- void*指针能做到事情有限：
  - 与其他指针进行比较
  - 作为函数的输入或输出
  - 赋值给另一个 void* 指针
- **不能直接操作void*指针指向的对象**





## 理解复合类型的声明

```C++
int i = 42;		
int *p = &i;	// p是一个int型指针
int *&r = p;	// r是对指针p的引用
```

要理解r的类型到底是什么，最简单的方法是**从右往左阅读r的定义**。

离变量名最近的符号（本例为`&`），对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分，用于确定r引用的类型是什么（本例为`*`，说明r引用的一个指向int的指针）。



## const限定符

- const对象一旦创建，其值不能修改。

- const对象必须初始化。

- 在默认情况下，const对象是内部链接的。

  > 如果想要在其他文件中使用它，则不管是声明还是定义都添加extern关键字。
  >
  > 例如：
  >
  > ```C++
  > extern const int x = 100;	// 定义const变量x
  > ```
  >
  > ```C++
  > extern const int x;
  > ```



### 对常量的引用（常量引用）

可以把引用，绑定到const对象上，称之为“**对常量的引用**”。

```C++
const int ci = 1024;
const int &r1 = ci;	// 正确，引用及其对应的对象都是常量

r1 = 42;	 	// 错误：r1是对常量的引用
int & r2 = ci;	// 错误：试图让一个非常量的引用，指向一个常量对象
```



> Tip：
>
> C++程序员，常常将“对const的引用”，简称为“**常量引用**”。



### 对常量的引用，可以绑定其他类型

引用的类型，必须与其所引用的对象的类型一致。但存在两种特例。



以下是一种特例情况：

**允许将常量引用，绑定到非常量的对象、字面值，甚至是一般表达式**。

```C++
int i = 42;
const int &r1 = i;		// 允许将const int&，绑定到普通int对象上
const int &r2 = 42;		// 正确：r2是一个常量引用
const int &r3 = r1*2;	// 正确：r3是一个常量引用

int &r4 = r1*2;		//错误：r4是一个普通的非常量引用
```



原因：

**当常量引用绑定到另一种类型时，其实绑定的是一个临时对象**。

```C++
double dval = 3.14;
const int &ri =dval;

// 等同于：
const int temp = dval;
const int &ri = temp;
```



### 指向常量的指针

指向常量的指针（pointer to const），不能用于改变其所指对象的值。

```C++
const double pi = 3.14;
double *ptr = &pi;			// 错误：ptr仅为普通指针
const double *cptr = &pi;	// 正确：cptr指向double常量
*cptr = 42;	// 错误：常量不允许改变
```



之前提过，指针的类型，必须与其所指对象的类型一致。但存在例外：

- 允许让一个指向常量的指针，指向一个非常量的对象。

  ```C++
  double dval = 3.14;
  const double *cptr = &dval;
  ```

  

### const指针（指针本身是个const）

把*放在const关键字前面，说明该指针本身是个常量。

```C++
int errNum = 0;
int *const curErr = &errNum;	// curErr指针，将一直指向errNum对象的地址
```

> 从右往左读，例如`const int *const ptr`，是一个const指针，它指向一个const int对象。



### 顶层Const 与 底层Const

用于描述指针：

- 顶层Const：

  指针**本身**是个常量。`int *const x`

- 底层Const：

  指针所指对象是个常量。`const int *`



## 常量表达式 与 constexpr变量

- 常量表达式：

  指**值不会改变**，且能**在编译阶段就能得到计算结果**的表达式。

- 一个对象（或表达式），是否为常量表达式：

  **由它的数据类型和初始值**共同决定。

  ```C++
  const int max_files = 20;		// 变量是常量表达式
  const int limit = max_files + 1;// 变量是
  int staff_size = 27;			// 不是
  
  const int sz = get_size();		// 表达式的值要到运行时才能获取，非常量表达式
  ```

  

- constexpr变量：

  声明为constexpr的**一定是常量**，且**必须使用常量表达式初始化**。

  ```C++
  constexpr int mf = 20;			// 20是常量表达式
  constexpr int limit = mf +1;	// mf+1是
  constexpr int sz = size();		// 仅当size()是一个constexpr时是
  ```

- 引用和指针类型，都能被定义成constexpr。

  > constexpr，**修饰的是指针本身**。因此该指针的初始化必须是nullptr或0或存储于固定地址中的对象（定义在函数体之外的对象）。
  >
  > > ```C++
  > > int x = 100; 	// x定义在函数体之外
  > > constexpr int *ptr1 = &x;		// 是常量指针，不能改变指针指向
  > > constexpr const int *ptr2 = &x;	// 是指向常量的常量指针
  > > ```





# 处理类型

## 类型别名

- 类型别名：

  是一个名字，是某种类型的同义词。



有两种方法，定义类型别名：

- `typedef`

  ```C++
  typedef double wages;		// wages是double的同义词
  typedef wages base, *p;		// base是double的同义词；p是double*的同义词
  ```

- `using`

  ```C++
  using SI = Sales_item;
  ```

  

## 指针、常量和类型别名

如果某个类型别名指代了复合类型或常量，不能简单的将它替换回本来的样子。

```C++
typedef char *pstring;
const pstring cstr = 0;	// cstr是指向char的常量指针
const pstring *ps;	// ps是一个指针，它指向的对象（是char* const)
```



## auto自动推断

```c++
auto item = val1 + val2;
```

可根据表达式，自动推断变量的类型。

> 也可以使用auto在一条语句中，定义多个变量。前提是这些变量的初始基本类型都一致。



- 引用与auto：

  auto的推断结果，为被引用对象的类型。

  ```C++
  int i = 0, &r = i;
  auto a = r;  // a是一个int
  ```

- auto会忽略顶层Const，保留底层const：

  ```C++
  int i = 0;
  const int ci = i,&cr = ci;
  auto b = ci;	// b是int
  auto c = cr;	// c是int
  auto d = &i;	// d是int*
  auto e = &ci;	// const int*
  ```

  > 如果希望推断出的类型，是一个顶层const，需要指明：
  >
  > ```C++
  > cosnt auto f = ci;	// ci推演出int，f是const int
  > ```



## decltype类型指示符

用于推断要定义变量的类型，但不使用该表达式的值初始化变量。

```C++
decltype(f()) sum = x;
```



若使用的表达式

- 是一个变量：

  返回该变量的类型（包括顶层const和引用在内）(区别于auto）。

  ```C++
  const int ci = 0, &cj = ci;
  decltype(ci) x = 0;		// x是const int
  decltype(cj) y = x;		// y是const int&
  decltype(cj) z;			// 错误,z是const int&，必须初始化
  ```

- 是一个表达式：

  返回表达式结果对应的类型。

  - 是引用，则返回引用类型。
  - 若解引用，返回的是引用

  

# 自定义数据类型

2.6节



# 字符串、向量、数组



# 表达式、语句、函数