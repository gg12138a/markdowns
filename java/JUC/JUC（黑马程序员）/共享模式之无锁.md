# 相对于使用管程的特点

都是为了解决并发带来的执行结果不可预期的问题。但：

- 使用管程（synchronized）：悲观锁
- 使用无锁并发：乐观锁



# 本章内容

- CAS 与 volatile
- 原子整数：JDK提供的基于无锁并发的典型实现
- 原子引用
- 原子累加器
- Unsafe类



# CAS的案例

- 接口：

  ```java
  interface Account {
      // 获取余额
      Integer getBalance();
      // 取款
      void withdraw(Integer amount);
  
      /**
       * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作
       * 如果初始余额为 10000 那么正确的结果应当是 0
       */
      static void demo(Account account) {
          List<Thread> ts = new ArrayList<>();
          long start = System.nanoTime();
          for (int i = 0; i < 1000; i++) {
              ts.add(new Thread(() -> {
                  account.withdraw(10);
              }));
          }
          ts.forEach(Thread::start);
          ts.forEach(t -> {
              try {
                  t.join();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          });
          long end = System.nanoTime();
          System.out.println(account.getBalance()
                  + " cost: " + (end-start)/1000_000 + " ms");
      }
  }
  ```

- 无锁的实现类：

  ```java
  public class AccountCas implements Account {
      private AtomicInteger balance;
  
      public AccountCas(Integer balance) {
          this.balance = new AtomicInteger(balance);
      }
  
      @Override
      public Integer getBalance() {
          return this.balance.get();
      }
  
      @Override
      public void withdraw(Integer amount) {
          while (true) {
              int prev = balance.get();
              int next = prev - amount;
  
              // (expectedValue, newValue)
              if (balance.compareAndSet(prev, next)) {
                  break;
              }
          }
      }
  
      public static void main(String[] args) {
          Account account = new AccountCas(10000);
          Account.demo(account);
      }
  }
  ```

  

# CAS与volatile

## 案例分析

前面看到的 AtomicInteger 的解决方法，**内部并没有用锁来保护共享变量的线程安全**。那么它是如何实现的呢？

```java
public void withdraw(Integer amount) {
    while(true) {
        // 需要不断尝试，直到成功为止
        while (true) {
            // 比如拿到了旧值 1000
            int prev = balance.get();
            // 在这个基础上 1000-10 = 990
            int next = prev - amount;
            
            /*
             compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值
             - 不一致了，next 作废，返回 false 表示失败
             比如，别的线程已经做了减法，当前值已经被减成了 990
             那么本线程的这次 990 就作废了，进入 while 下次循环重试
             - 一致，以 next 设置为新值，返回 true 表示成功
             */
            if (balance.compareAndSet(prev, next)) {
                break;
            }
        }
    }
}
```

其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是**原子操作**。

> CAS操作，是在CPU指令集级别上（X86架构的lock cmpxchg指令）提供的支持。
>
> ***能保证比较并交换操作的原子性***。
>
> > 在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。



![image-20220514170128704](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%97%A0%E9%94%81.assets/image-20220514170128704.png)



## volatile

获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。

它可以用来修饰成员变量和静态成员变量，他可以**避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值**，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。

> #### 💡注意
>
> volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）

CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果



`AtomicInteger`类：

```java
public class AtomicInteger extends Number implements java.io.Serializable {
	
    ...
    private volatile int value;
}
```



## 为什么无锁效率高

- 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇；
- 而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。



## CAS的特点

结合 CAS 和 volatile 可以实现无锁并发，**适用于线程数少、多核 CPU 的场景**下。

- CAS 是基于**乐观锁**的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。
- synchronized 是基于**悲观锁**的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 改，我改完了解开锁，你们才有机会。
- CAS 体现的是**无锁并发、无阻塞并发**，请仔细体会这两句话的意思
  - 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一
  - 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响



# 原子整数

J.U.C 并发包提供了：

- AtomicBoolean
- AtomicInteger
- AtomicLong



以 AtomicInteger 为例：

```java
AtomicInteger i = new AtomicInteger(0);

// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++
System.out.println(i.getAndIncrement());

// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i
System.out.println(i.incrementAndGet());

// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i
System.out.println(i.decrementAndGet());

// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--
System.out.println(i.getAndDecrement());

// 获取并加值（i = 0, 结果 i = 5, 返回 0）
System.out.println(i.getAndAdd(5));

// 加值并获取（i = 5, 结果 i = 0, 返回 0）
System.out.println(i.addAndGet(-5));

// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.getAndUpdate(p -> p - 2));

// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.updateAndGet(p -> p + 2));

// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的
// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final
System.out.println(i.getAndAccumulate(10, (p, x) -> p + x));

// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.accumulateAndGet(-10, (p, x) -> p + x));
```



# 原子引用

[黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16J411h7Rd?p=169)
