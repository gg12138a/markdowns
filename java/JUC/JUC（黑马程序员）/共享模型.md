# 本章内容

- 共享问题
- synchronized
- 线程安全分析
- Monitor
- wait/notify
- 线程状态转换
- 活跃性
- Lock



# 共享带来的问题

## 经典的线程不安全案例

```java
@Slf4j
public class Test17 {

    public static int counter =0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            for(int i = 0;i<5000;i++){
                counter++;
            }
        },"t1");

        Thread t2 = new Thread(() -> {
            for(int i = 0;i<5000;i++){
                counter--;
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        log.debug("{}",counter);
    }
}
```

会发现，counter的运行结果大概率不为0



## 问题分析

在Java中，***对静态变量的自增、自减，并非原子操作***：

- 自增：如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：

  ```java
  getstatic i // 获取静态变量i的值
  iconst_1 // 准备常量1
  iadd // 自增
  putstatic i // 将修改后的值存入静态变量i
  ```

- 自减：

  ```java
  getstatic i // 获取静态变量i的值
  iconst_1 // 准备常量1
  isub // 自减
  putstatic i // 将修改后的值存入静态变量i
  ```



对应的Java内存模型如下，对于静态变量的自增、自减，***需要在主存和工作内存中进行数据交换***：

<img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420162717448.png" alt="image-20220420162717448" style="zoom: 50%;" />



如果是单线程的情况，上述的代码将顺序执行，不会导致错误：

<img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420162936884.png" alt="image-20220420162936884" style="zoom: 67%;" />



但在多线程的情况下，上述的代码可能交错运行，例如：

- 出错负数的情况：

  <img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420163027284.png" alt="image-20220420163027284" style="zoom: 67%;" />

- 出现正数的情况：

  <img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420163045405.png" alt="image-20220420163045405" style="zoom:67%;" />



## **临界区** **Critical Section**

- 一个程序运行多个线程本身是没有问题的

- 问题出在多个线程访问**共享资源**
  - 多个线程读**共享资源**其实也没有问题
  - 在多个线程对**共享资源**读写操作时发生指令交错，就会出现问题

- *一段代码块内如果存在对**共享资源**的多线程读写操作，称这段代码块为**临界区***。例如：

  ```java
  static int counter = 0;
  
  static void increment() 
      // 临界区
  { 
      counter++; 
  }
  
  static void decrement() 
      // 临界区
  { 
      counter--; 
  }
  ```

  

## **竞态条件** **Race Condition**

多个线程在临界区内执行，由于代码的**执行序列不同**而导致结果无法预测，称之为发生了**竞态条件**

https://www.bilibili.com/video/BV16J411h7Rd?p=53



# synchronized

## 应用之“互斥”

为了避免临界区的竞态条件发生，有多种手段可以达到目的：

- 阻塞式的解决方案：synchronized，Lock
- 非阻塞式的解决方案：原子变量



本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【***对象锁***】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换



>**注意**，虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：
>
>- 互斥：保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
>- 同步：由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点



## synchronized语法

```java
synchronized(对象){
    临界区
}
```



- 若对象锁已被某个线程占用，其余线程将发生上下文切换，进入阻塞状态；
- 若某个线程执行完synchronized{}块内的代码，***其将释放对象锁，并唤醒阻塞进程***。



注意，若某个线程获取了对象锁，***即便其时间片到而下处理机，也不会释放对象锁***。



## 面向过程的解决方案

例如：

```java
@Slf4j
public class Test18 {

    public static int counter =0;
    public static final Object room = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            for(int i = 0;i<5000;i++){
                synchronized (room){
                    counter++;
                }
            }
        },"t1");

        Thread t2 = new Thread(() -> {
            for(int i = 0;i<5000;i++){
                synchronized (room){
                    counter--;
                }
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        log.debug("{}",counter);
    }
}
```



## 面向对象的解决方案

```java
@Slf4j
public class Room {
    private int counter = 0;

    public void increment(){
        synchronized (this){
            counter++;
        }
    }

    public void decrement(){
        synchronized (this){
            counter--;
        }
    }

    public int getCounter() {
        synchronized (this){
            return counter;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Room room = new Room();

        Thread t1 = new Thread(()->{
            for (int i=0;i<5000;i++){
                room.increment();
            }
        },"t1");

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                room.decrement();
            }
        }, "t2");

        t1.start();
        t2.start();

        t1.join();;
        t2.join();

        log.debug("{}",room.getCounter());
    }
}
```



## synchronized方法

- 成员方法上的synchronized：

  ```java
  public synchronized void test() {
  
  }
  
  //等价于
  public void test() {
      synchronized(this) {
  
      }
  }
  
  ```

  

- 静态方法上的synchronized：

  ```java
  public synchronized static void test() {
  }
  
  //等价于
  public static void test() {
      synchronized(Test.class) {
  
      }
  }
  ```



# 变量的线程安全分析

https://www.bilibili.com/video/BV16J411h7Rd?p=63



## 成员变量与静态变量是否安全

- 如果它们没有共享，则线程安全
- 如果它们***被共享***了，根据它们的状态是否能够改变，又分两种情况：
  - 如果只有读操作，则线程安全
  - ***如果有读写操作，则这段代码是临界区，需要考虑线程安全***



## 局部变量是否线程安全

- 局部变量是线程安全的
- 但***局部变量引用的对象***则未必：
  - 如果该对象没有逃离方法的作用访问，它是线程安全的
  - ***如果该对象逃离方法的作用范围，需要考虑线程安全***



### 安全的例子

```java
public static void test1() {
    int i = 10;
    i++;
}
```

每个线程调用 test1() 方法时局部变量 i，会在***每个线程的栈帧内存中被创建多份，因此不存在共享***

<img src="C:\Users\27933\AppData\Roaming\Typora\typora-user-images\image-20220421190006089.png" alt="image-20220421190006089" style="zoom: 80%;" />



### 不安全的例子

```java
public class ThreadUnsafe {
    ArrayList<String> list = new ArrayList<>();

    public void method1(int loopNumber){
        for(int i=0; i<loopNumber;i++){
            // { 临界区，会产生竞态条件
            method2();
            method3();
            // } 临界区
        }
    }

    private void method2() {
        list.add("1");
    }

    private void method3() {
        list.remove(0);
    }

    public static void main(String[] args) {
        ThreadUnsafe test= new ThreadUnsafe();

        for(int i =0;i< 2 ;i++){
            new Thread(()->{
               test.method1(200);
            },"thread"+i).start();
        }
    }
}
```

可能导致如下异常：

```java
Exception in thread "thread0" java.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:64)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:70)
	at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:248)
	at java.base/java.util.Objects.checkIndex(Objects.java:372)
	at java.base/java.util.ArrayList.remove(ArrayList.java:536)
	at n4.ThreadUnsafe.method3(ThreadUnsafe.java:20)
	at n4.ThreadUnsafe.method1(ThreadUnsafe.java:11)
	at n4.ThreadUnsafe.lambda$main$0(ThreadUnsafe.java:28)
	at java.base/java.lang.Thread.run(Thread.java:829)
```



分析如下：

<img src="C:\Users\27933\AppData\Roaming\Typora\typora-user-images\image-20220421190926927.png" alt="image-20220421190926927" style="zoom:80%;" />





但倘若将list，修改为局部变量：

```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
        list.add("1");
    }
    private void method3(ArrayList<String> list) {
        list.remove(0);
    }
}
```

则不会产生上述问题。这是因为：

- list 是局部变量，每个线程调用时会创建其不同实例，没有共享
- 而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象

<img src="C:\Users\27933\AppData\Roaming\Typora\typora-user-images\image-20220421191236392.png" alt="image-20220421191236392" style="zoom:80%;" />





### 局部变量的暴露引用问题

```java
class ThreadSafe {
    public void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
        list.add("1");
    }
    private void method3(ArrayList<String> list) {
        list.remove(0);
    }
}

//此子类并非线程安全的
class ThreadSafeSubClass extends ThreadSafe{
    @Override
    public void method3(ArrayList<String> list) {
        new Thread(() -> {
            list.remove(0);
        }).start();
    }
}

```

对ThreadSafe类进行考虑：

- 情况1：有其它线程调用 method2 和 method3 情况2：
  - 若method2为private的，显然是安全的。
  - 若method2为public的，调用method2传入的list对象是外部的，若外部创建新线程操作此list对象，仍将产生竞态条件，是线程不安全的。
- 在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，并使用新线程操作list对象：是线程不安全的。因为主线程将与新线程同时操作list对象，产生竞态条件

> 从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会面向对象的开闭原则中的【闭】



## 常见的线程安全类

[黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16J411h7Rd?p=67&spm_id_from=pageDriver)
