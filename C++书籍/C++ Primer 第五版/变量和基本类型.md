# C++是静态强类型语言

- 静态语言：

  变量类型的检查，在编译期间。

- 强类型语言：

  变量类型被定义后，不能自动转换。需要进行强制类型转换。





# 内置类型

## 算数类型

|    类型     |      含义      |   最小尺寸   |
| :---------: | :------------: | :----------: |
|    bool     |    布尔类型    |    未定义    |
|    char     |      字符      |     8bit     |
|   wchar_t   |     宽字符     |    16bit     |
|  char16_t   |  Unicode字符   |    16bit     |
|  char32_t   |  Unicode字符   |    32bit     |
|    short    |     短整型     |    16bit     |
|     int     |      整型      |    16bit     |
|    long     |     长整型     |    32bit     |
|  long long  |     长整型     |    64bit     |
|    float    |  单精度浮点数  | 6位有效数字  |
|   double    |  双精度浮点数  | 10位有效数字 |
| long double | 拓展精度浮点数 | 10位有效数字 |



> 注意：
>
> char类型，存在signed char 和 unsigned char共三种。
>
> > 不同于数字类型，char的默认，不一定是signed的（取决于编译器）。



## 数值类型的自动类型转换

```c++
bool b = 42;    // b为真
    int i = b;      // i为1
    i = 3.14;       // i为3
    double pi = i;  // pi为3.0
    unsigned char c = -1;   // 假设char占8bit，c为255
    signed  char c2 = 256;  // 假设char占8bit，c2的值undefined
```



- 对无符号类型，给它一个超出表示范围的值：

  若该无符号类型8bit（表示范围0~255)，赋x，结果为x mod 256。

- 对有符号类型，给它一个超出表示范围的值：

  结果将是undefined。

  > 程序此时可能：
  >
  > - 继续工作
  > - 崩溃
  > - 产生垃圾数据



## 无符号类型参与运算的表达式

> signed数，会自动转型为unsigned数。
>
> - 负数转无符号数：对字节，按照补码进行解释。
>
>   

- unsigned类型，参与加法：

  有符号数，将自动转型为无符号数，表达式结果类型为无符号类型。

  结果为无符号数的模，加该负数。例如：-42转为4字节无符号数，结果为4294967296 - 42 = 4294967264。

- unsigned类型，参与减法：

  你必须保证，逻辑上的结果值不能为负数（因为采用补码正数对字节数进行解释）。

  一个死循环如下：

  ```C++
  for (unsigend u = 10; u>=0 ; u--){};
  // 假设int类型为32位，当u=0时，--u的结果为4294967295
  ```

  



## 字面值常量

2.1.3 字面值常量







# 自定义数据类型



# 字符串、向量、数组



# 表达式、语句、函数