# 本章内容

- 共享问题
- synchronized
- 线程安全分析
- Monitor
- wait/notify
- 线程状态转换
- 活跃性
- Lock



# 共享带来的问题

## 经典的线程不安全案例

```java
@Slf4j
public class Test17 {

    public static int counter =0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            for(int i = 0;i<5000;i++){
                counter++;
            }
        },"t1");

        Thread t2 = new Thread(() -> {
            for(int i = 0;i<5000;i++){
                counter--;
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        log.debug("{}",counter);
    }
}
```

会发现，counter的运行结果大概率不为0



## 问题分析

在Java中，***对静态变量的自增、自减，并非原子操作***：

- 自增：如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：

  ```java
  getstatic i // 获取静态变量i的值
  iconst_1 // 准备常量1
  iadd // 自增
  putstatic i // 将修改后的值存入静态变量i
  ```

- 自减：

  ```java
  getstatic i // 获取静态变量i的值
  iconst_1 // 准备常量1
  isub // 自减
  putstatic i // 将修改后的值存入静态变量i
  ```



对应的Java内存模型如下，对于静态变量的自增、自减，***需要在主存和工作内存中进行数据交换***：

<img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420162717448.png" alt="image-20220420162717448" style="zoom: 50%;" />



如果是单线程的情况，上述的代码将顺序执行，不会导致错误：

<img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420162936884.png" alt="image-20220420162936884" style="zoom: 67%;" />



但在多线程的情况下，上述的代码可能交错运行，例如：

- 出错负数的情况：

  <img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420163027284.png" alt="image-20220420163027284" style="zoom: 67%;" />

- 出现正数的情况：

  <img src="%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.assets/image-20220420163045405.png" alt="image-20220420163045405" style="zoom:67%;" />



## **临界区** **Critical Section**

- 一个程序运行多个线程本身是没有问题的

- 问题出在多个线程访问**共享资源**
  - 多个线程读**共享资源**其实也没有问题
  - 在多个线程对**共享资源**读写操作时发生指令交错，就会出现问题

- *一段代码块内如果存在对**共享资源**的多线程读写操作，称这段代码块为**临界区***。例如：

  ```java
  static int counter = 0;
  
  static void increment() 
      // 临界区
  { 
      counter++; 
  }
  
  static void decrement() 
      // 临界区
  { 
      counter--; 
  }
  ```

  

## **竞态条件** **Race Condition**

多个线程在临界区内执行，由于代码的**执行序列不同**而导致结果无法预测，称之为发生了**竞态条件**

https://www.bilibili.com/video/BV16J411h7Rd?p=53



# synchronized

## 应用之“互斥”

为了避免临界区的竞态条件发生，有多种手段可以达到目的：

- 阻塞式的解决方案：synchronized，Lock
- 非阻塞式的解决方案：原子变量



本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【***对象锁***】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换



>**注意**，虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：
>
>- 互斥：保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
>- 同步：由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点



## synchronized语法

```java
synchronized(对象){
    临界区
}
```



- 若对象锁已被某个线程占用，其余线程将发生上下文切换，进入阻塞状态；
- 若某个线程执行完synchronized{}块内的代码，***其将释放对象锁，并唤醒阻塞进程***。



注意，若某个线程获取了对象锁，***即便其时间片到而下处理机，也不会释放对象锁***。



## 面向过程的解决方案

例如：

```java
@Slf4j
public class Test18 {

    public static int counter =0;
    public static final Object room = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            for(int i = 0;i<5000;i++){
                synchronized (room){
                    counter++;
                }
            }
        },"t1");

        Thread t2 = new Thread(() -> {
            for(int i = 0;i<5000;i++){
                synchronized (room){
                    counter--;
                }
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        log.debug("{}",counter);
    }
}
```



## 面向对象的解决方案

```java
@Slf4j
public class Room {
    private int counter = 0;

    public void increment(){
        synchronized (this){
            counter++;
        }
    }

    public void decrement(){
        synchronized (this){
            counter--;
        }
    }

    public int getCounter() {
        synchronized (this){
            return counter;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Room room = new Room();

        Thread t1 = new Thread(()->{
            for (int i=0;i<5000;i++){
                room.increment();
            }
        },"t1");

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                room.decrement();
            }
        }, "t2");

        t1.start();
        t2.start();

        t1.join();;
        t2.join();

        log.debug("{}",room.getCounter());
    }
}
```



## synchronized方法

- 成员方法上的synchronized：

  ```java
  public synchronized void test() {
  
  }
  
  //等价于
  public void test() {
      synchronized(this) {
  
      }
  }
  
  ```

  

- 静态方法上的synchronized：

  ```java
  public synchronized static void test() {
  }
  
  //等价于
  public static void test() {
      synchronized(Test.class) {
  
      }
  }
  ```



# 变量的线程安全分析

https://www.bilibili.com/video/BV16J411h7Rd?p=63



## 成员变量与静态变量是否安全

- 如果它们没有共享，则线程安全
- 如果它们***被共享***了，根据它们的状态是否能够改变，又分两种情况：
  - 如果只有读操作，则线程安全
  - ***如果有读写操作，则这段代码是临界区，需要考虑线程安全***



## 局部变量是否线程安全

- 局部变量是线程安全的
- 但***局部变量引用的对象***则未必：
  - 如果该对象没有逃离方法的作用访问，它是线程安全的
  - ***如果该对象逃离方法的作用范围，需要考虑线程安全***



### 安全的例子

```java
public static void test1() {
    int i = 10;
    i++;
}
```

每个线程调用 test1() 方法时局部变量 i，会在***每个线程的栈帧内存中被创建多份，因此不存在共享***

<img src="C:\Users\27933\AppData\Roaming\Typora\typora-user-images\image-20220421190006089.png" alt="image-20220421190006089" style="zoom: 80%;" />



### 不安全的例子

```java
public class ThreadUnsafe {
    ArrayList<String> list = new ArrayList<>();

    public void method1(int loopNumber){
        for(int i=0; i<loopNumber;i++){
            // { 临界区，会产生竞态条件
            method2();
            method3();
            // } 临界区
        }
    }

    private void method2() {
        list.add("1");
    }

    private void method3() {
        list.remove(0);
    }

    public static void main(String[] args) {
        ThreadUnsafe test= new ThreadUnsafe();

        for(int i =0;i< 2 ;i++){
            new Thread(()->{
               test.method1(200);
            },"thread"+i).start();
        }
    }
}
```

可能导致如下异常：

```java
Exception in thread "thread0" java.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:64)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:70)
	at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:248)
	at java.base/java.util.Objects.checkIndex(Objects.java:372)
	at java.base/java.util.ArrayList.remove(ArrayList.java:536)
	at n4.ThreadUnsafe.method3(ThreadUnsafe.java:20)
	at n4.ThreadUnsafe.method1(ThreadUnsafe.java:11)
	at n4.ThreadUnsafe.lambda$main$0(ThreadUnsafe.java:28)
	at java.base/java.lang.Thread.run(Thread.java:829)
```



分析如下：

<img src="C:\Users\27933\AppData\Roaming\Typora\typora-user-images\image-20220421190926927.png" alt="image-20220421190926927" style="zoom:80%;" />





但倘若将list，修改为局部变量：

```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
        list.add("1");
    }
    private void method3(ArrayList<String> list) {
        list.remove(0);
    }
}
```

则不会产生上述问题。这是因为：

- list 是局部变量，每个线程调用时会创建其不同实例，没有共享
- 而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象

<img src="C:\Users\27933\AppData\Roaming\Typora\typora-user-images\image-20220421191236392.png" alt="image-20220421191236392" style="zoom:80%;" />





### 局部变量的暴露引用问题

```java
class ThreadSafe {
    public void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
        list.add("1");
    }
    private void method3(ArrayList<String> list) {
        list.remove(0);
    }
}

//此子类并非线程安全的
class ThreadSafeSubClass extends ThreadSafe{
    @Override
    public void method3(ArrayList<String> list) {
        new Thread(() -> {
            list.remove(0);
        }).start();
    }
}

```

对ThreadSafe类进行考虑：

- 情况1：有其它线程调用 method2 和 method3 情况2：
  - 若method2为private的，显然是安全的。
  - 若method2为public的，调用method2传入的list对象是外部的，若外部创建新线程操作此list对象，仍将产生竞态条件，是线程不安全的。
- 在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，并使用新线程操作list对象：是线程不安全的。因为主线程将与新线程同时操作list对象，产生竞态条件

> 从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会面向对象的开闭原则中的【闭】



## 常见的线程安全类

[黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16J411h7Rd?p=67&spm_id_from=pageDriver)

- String
- Integer（即包装类）
- StringBuffer
- Random
- Vector
- Hashtable
- java.util.concurrent包下的类

> 此处的线程安全，是指：多个线程调用它们的***同一个实例时***的某个方法时，是线程安全的。也可以理解为：
>
> - 它们的每个方法都是原子的
> - 但注意，它们***多个方法的组合，并不是原子的***。



### 线程安全类的方法组合问题

虽然get和put方法是线程安全的，但如下的代码是非线程安全的：

```java
Hashtable table = new Hashtable();

//线程1和线程2都执行如下代码：
if(table.get("key") == null){
	table.put("key", value);
}
```



```mermaid
sequenceDiagram
participant t1 as 线程1
participant t2 as 线程2
participant table

t1 ->> table : get("key")==null
t2 ->> table : get("key")==null
t2 ->> table : put("key",v2)
t1 ->> table : put("key",v1)
```



### 不可变类的线程安全性

String、Integer等都是不可变类（<u>**内部的状态(即属性)不可以被改变**</u>），它们的方法都是线程安全的。



对于String类来说，它的replace、substring等方法：返回的是***新String对象***

```java
public String substring(int beginIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    int subLen = length() - beginIndex;
    if (subLen < 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    if (beginIndex == 0) {
        return this;
    }
    return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)
        : StringUTF16.newString(value, beginIndex, subLen);
}
```



## 案例分析

> 在tomcat中，Servlet只有一个实例，将被多个线程共享使用

```java
public class MyServlet extends HttpServlet{
    Map <String,Objcet> map = new HashMap<>(); //非线程安全
    
    String s1 = "...";			//线程安全
    final String s2 = "...";	 //线程安全
    
    Date d1 = new Date();		//非线程安全
    final Date d2 = new Date();	 //非线程安全

    public void doGet(HttpServletRequest request, HttpServletResponse response){
    	//使用上述变量    
    }
}
```



例2：

```java
public class MyServlet extends HttpServlet{
    private UserService userservice = new UserServiceImpl();	//非线程安全

    public void doGet(HttpServletRequest request, HttpServletResponse response){
    	userService.update();    
    }
}

public class UserServiceImpl implements UserSerivice{
    private int count = 0;
    
    public void update(){
        count++;
    }
}
```



> Spring的组件，***默认是单例的***。用环绕通知可解决此问题

例3：

```java
@Aspect
@Component
public class MyAspect{
    private long start = 0L;
    
    @Before("execution(* *(..))")
    public void before(){
        start = System.nanoTime();	//非线程安全
    }
    
    @After("execution(* *(..))")
    public void after(){
        long end = System.nanoTime();
        System.out.println("cost Time:" + (end-start));
    }
}
```



例4：

```java
public class MyServlet extends HttpServlet
    //线程安全
    private Userservice userservice = new UserserviceImpl();

    public void doGet(HttpServletRequest request,HttpServletResponse response){
        userService.update(...);
    }
}

public class UserServiceImpl implements UserService
    //线程安全，因为此对象是无状态的
    private UserDao userDao = new UserDaoImp1();

    public void update(){
        userDao.update();
    }
}

public class UserDaoImpl implements UserDao
    public void update(){
        String sql ="update user set password where username ?";
        //线程安全
        try (Connection conn = DriverManager.getconnection("","","")){
            //···
        }catch (Exception e){
            //··…
        }
}
```

​          

例5：

```java
public class MyServlet extends HttpServlet {
    // 非线程安全
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}

public class UserServiceImpl implements UserService {
    // 非线程安全
    private UserDao userDao = new UserDaoImpl();

    public void update() {
        userDao.update();
    }
}

public class UserDaoImpl implements UserDao {
    // 非线程安全
    private Connection conn = null;
    public void update() throws SQLException {
        String sql = "update user set password = ? where username = ?";
        conn = DriverManager.getConnection("","","");
        // ...
        conn.close();
    }
}
```



例6：

```java
public class MyServlet extends HttpServlet {
    // 线程安全
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}

public class UserServiceImpl implements UserService { 
    public void update() {
        UserDao userDao = new UserDaoImpl();
        userDao.update();
    }
}

public class UserDaoImpl implements UserDao {
    // 非线程安全
    private Connection = null;
    public void update() throws SQLException {
        String sql = "update user set password = ? where username = ?";
        conn = DriverManager.getConnection("","","");
        // ...
        conn.close();
    }
}
```



例7：

```java
public abstract class Test {

    public void bar() {
        // 是否安全
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        foo(sdf);
    }
    
    public abstract foo(SimpleDateFormat sdf);

    public static void main(String[] args) {
        new Test().bar();
    }
}

```

其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为***外星方法***

```java
public void foo(SimpleDateFormat sdf) {
    String dateStr = "1999-10-11 00:00:00";
    for (int i = 0; i < 20; i++) {
        new Thread(() -> {
            try {
                sdf.parse(dateStr);
            } catch (ParseException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```



例8：

```java
private static Integer i = 0;
public static void main(String[] args) throws InterruptedException {
    List<Thread> list = new ArrayList<>();
    for (int j = 0; j < 2; j++) {
        Thread thread = new Thread(() -> {
            for (int k = 0; k < 5000; k++) {
                synchronized (i) {
                    i++;
                }
            }
        }, "" + j);
        list.add(thread);
    }
    list.stream().forEach(t -> t.start());
    list.stream().forEach(t -> {
        try {
            t.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    log.debug("{}", i);
}
```



## 习题

[黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16J411h7Rd?p=71&spm_id_from=pageDriver)
