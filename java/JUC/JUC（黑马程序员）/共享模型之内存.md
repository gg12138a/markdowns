# 本章内容

- 上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性
- 这一章我们进一步深入学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题



# Java内存模型

JMM 即 Java Memory Model，它定义了**主存**、**工作内存**抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。

- 主存：存储所有线程的共享信息
- 工作内存：存储线程私有的信息





JMM 体现在以下几个方面：

- 原子性 - 保证指令不会受到线程上下文切换的影响
- 可见性 - 保证指令不会受 cpu <u>缓存</u>的影响
- 有序性 - 保证指令不会受 cpu 指令<u>并行优化</u>的影响



# 可见性

## 退不出的循环

```java
@Slf4j(topic = "c.Test32")
public class Test32 {

    static boolean run = true;

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            while (run) {

            }
            log.debug("stopped");
        });

        t.start();
        Thread.sleep(1000);
        log.debug("should stop then");
        run = false;
    }
}
```

一秒之后，t线程并不会像预期那样被停止。



原因在于：

1. 在初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。

   ![image-20220502202051364](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98.assets/image-20220502202051364.png)

2. 因为 t 线程要频繁从主内存中读取 run 的值，***JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中***， 减少对主存中 run 的访问，提高效率

   ![image-20220502202059488](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98.assets/image-20220502202059488.png)

3. 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值

   ![image-20220502202108952](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98.assets/image-20220502202108952.png)



## 解决方法

`volatile`（易变关键字）：

它可以用来修饰***成员变量***和***静态成员变量***，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，***线程操作 volatile 变量都是直接操作主存***



> 事实上，synchronized关键字也能保证变量的可见性：
>
> ```java
> @Slf4j(topic = "c.Test32")
> public class Test32 {
> 
>     static boolean run = true;
> 
>     final static Object lock = new Object();
> 
>     public static void main(String[] args) throws InterruptedException {
>         Thread t = new Thread(() -> {
>             while (true) {
> 
>                 synchronized (lock) {
>                     if (!run) {
>                         break;
>                     }
>                 }
>             }
>             log.debug("stopped");
>         });
> 
>         t.start();
> 
>         Thread.sleep(1000);
>         log.debug("should stop then");
> 
>         synchronized (lock) {
>             run = false;
>         }
>     }
> }
> ```



## 可见性 vs 原子性

前面例子体现的实际就是可见性，它保证的是在多个线程之间：

- ***一个线程对 volatile 变量的修改对另一个线程可见***（因为此时对变量的修改，都是对主存的修改）

- 但不能保证原子性（因为只能保证看到「最新值」，不能解决指令交错的问题）。仅用在一个写线程，多个读线程的情况



[上例](#退不出的循环)从字节码理解是这样的：

```java
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
putstatic run // 线程 main 修改 run 为 false， 仅此一次
getstatic run // 线程 t 获取 run false 
```



>#### 💡注意：
>
>- synchronized 语句块既可以保证代码块的原子性，**也同时保证代码块内变量的可见性**。
>- 但缺点是 synchronized 是属于重量级操作，性能相对更低 序性



## 设计模式之两阶段停止

见JUC设计模式.md

```java
public class Test8 {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination tpt = new TwoPhaseTermination();

        tpt.start();
        Thread.sleep(5_000);
        tpt.stop();
    }
}

@Slf4j(topic = "c.monitor")
class TwoPhaseTermination {
    private Thread monitor;
    private volatile boolean stop;

    public void start() {
        monitor = new Thread(() -> {
            while (true) {
                if (stop) {
                    log.debug("线程被打断，将要退出");
                    break;
                }

                try {
                    Thread.sleep(2_000);
                    log.debug("记录监控信息");
                } catch (InterruptedException e) {

                    stop = true;    // 考虑被打断的情况
                    e.printStackTrace();
                }
            }
        });

        monitor.start();
    }

    public void stop() {
        stop = true;
    }
}
```



# 有序性

JVM 会在不影响正确性的前提下，可以调整语句的执行顺序。



## 指令重排

思考下面一段代码：

```java
static int i;
static int j;
// 在某个线程内执行如下赋值操作
i = ...; 
j = ...; 
```

可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是：
```java
i = ...; 
j = ...;
```

也可以是：

```java
j = ...;
i = ...; 
```



***这种特性称之为『指令重排』，但在多线程下『指令重排』会影响正确性***。



### 指令重排的原理

每条指令都可以分为： `取指令` - `指令译码` - `执行指令` - `内存访问` - `数据写回` 这 5 个阶段

![image-20220502215003895](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98.assets/image-20220502215003895.png)

>术语参考：
>
>- instruction fetch (IF)
>- instruction decode (ID)
>- execute (EX)
>- memory access (MEM)
>- register write back (WB)

在不改变程序结果的前提下，这些指令的各个阶段可以通过**重排序**和组合来实现**指令级并行**



### 支持流水线的处理器

现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理 器，就可以称之为**五级指令流水线**。

这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了 指令地吞吐率

![image-20220502215335426](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98.assets/image-20220502215335426.png)



### SuperScalar 处理器

大多数处理器包含多个执行单元，并不是所有计算功能都集中在一起，可以再细分为整数运算单元、浮点数运算单元等，这样可以把多条指令也可以做到并行获取、译码等，CPU 可以在一个时钟周期内，执行多于一条指令，IPC> 1

![image-20220502215417223](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98.assets/image-20220502215417223.png)



## 指令重排导致出错的例子

```java
int num = 0;
boolean ready = false;

// 线程1 执行此方法
public void actor1(I_Result r) {
    if(ready) {
        r.r1 = num + num;
    } else {
        r.r1 = 1;
    }
}

// 线程2 执行此方法
public void actor2(I_Result r) { 
    num = 2;
    ready = true; 
}
```

I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？

- 线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1

- 线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1

- 线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）

- **指令重排的情况**：

  线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2



### 复现

[视频链接](https://www.bilibili.com/video/BV16J411h7Rd?p=144&spm_id_from=pageDriver)



这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：

- 借助 java 并发压测工具 jcstress https://wiki.openjdk.java.net/display/CodeTools/jcstress

```sh
mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test-archetype -DarchetypeVersion=0.5 -DgroupId=cn.itcast -DartifactId=ordering -Dversion=1.0 
```

1. 创建 maven 项目，提供如下测试类：

   ```java
   @JCStressTest
   @Outcome(id = {"1", "4"}, expect = Expect.ACCEPTABLE, desc = "ok")
   @Outcome(id = "0", expect = Expect.ACCEPTABLE_INTERESTING, desc = "!!!!")
   @State
   public class ConcurrencyTest {
       int num = 0;
       boolean ready = false;
       @Actor
       public void actor1(I_Result r) {
           if(ready) {
               r.r1 = num + num;
           } else {
               r.r1 = 1;
           }
       }
       @Actor
       public void actor2(I_Result r) {
           num = 2;
           ready = true;
       }
   }
   ```

2. 执行：

   ```
   mvn clean install 
   java -jar target/jcstress.jar 
   ```

3. 会输出我们感兴趣的结果，摘录其中一次结果：

   ![image-20220502221028632](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98.assets/image-20220502221028632.png)

   可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。

   

### 解决方法（volatile）

***volatile 修饰的变量，可以禁用指令重排***。



```java
@JCStressTest

@Outcome(id = {"1", "4"}, expect = Expect.ACCEPTABLE, desc = "ok")
@Outcome(id = "0", expect = Expect.ACCEPTABLE_INTERESTING, desc = "!!!!")
@State
public class ConcurrencyTest {
    int num = 0;
    volatile boolean ready = false;
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    @Actor
    public void actor2(I_Result r) {
        num = 2;
        // 在ready上添加volatile，可以保证在此之前的代码不会被重排
        ready = true;
    }
}
```

结果为：

```
*** INTERESTING tests 
 Some interesting behaviors observed. This is for the plain curiosity. 
 
 0 matching test results. 
```



# volatile原理

[黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16J411h7Rd?p=146&spm_id_from=pageDriver)
