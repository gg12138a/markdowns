本章将进一步了解虚拟机中数据的其他细节：譬如它们是如何创建、布局以及如何访问的。

对于这样涉及细节的问题，必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域上才有意义。基于实用优先的原则，以最常用的虚拟机HotSpot，最常用的内存区域Java堆为例。深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

# 对象的创建

Java是一门面向对象的编程语言，Java程序运行过程中，无时无刻都有对象被创建出来。

在语言层面：创建对象(例如：复制、反序列化)仅仅是一个new关键字而已。

在虚拟机中，对象(此处讨论仅限于普通Java对象，不包括数组和Class对象等)的创建过程：

当虚拟机遇到一条字节码new指令时：

1. 首先将去检查这个指令的参数，是否能在常量池中定位到一个类的符号引用

2. 并且坚持这个符号引用代表的类，是否已经被加载、解析和初始化过。

    > 如果没有，必须先执行相应的[类加载过程](https://www.notion.so/887ef76d7de14369bc7133ffe0977dac)。

3. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。

    - 对象所需内存的大小，在类加载完成后便可完全确定。为对象分配空间的任务，实际上便等同于把一块确定大小的内存块，从Java堆中划分出来

    - 具体的分配方式，由Java堆是否规整决定。而Java堆是否规整，又由所采用的垃圾收集器是否带有空间压缩整理(Compact)的能力决定。

        - 当使用Serial、ParNew等带压缩整理过程的收集器时，采用的分配算法是指针碰撞。

            > 指针碰撞：Java堆中的内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器。分配内存就仅仅是把该指针向空闲空间方向，挪动一段与对象大小相等的距离

        - 当使用CMS这种基于清除算法(Sweep)的收集器时，理论上就只能采用较为复杂的空闲列表(Free List)来分配内存。

            > 空闲列表：Java堆中的内存是不规整的，已被使用的内存和空闲的内存相互交错，虚拟机需要维护一个列表，记录哪些内存块是可用的。分配内存就是从列表中找到一块足够大的空间，将其划分给对象实例，并更新表上的记录

    - 对象创建在虚拟机中是非常频繁的行为，需要考虑在并发情况下的线程安全问题。

        例如：正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的真正来分配内存的情况。

        解决方式：

        1. 对分配内存空间的行为，进行同步处理。

            实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性

        2. 把内存分配的动作，按照线程划分在不同的空间中进行。

            即每个线程，在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)，哪个线程要分配内存，就在线程所属的本地缓冲区中进行分配。只有本地缓冲区用完时，分配新的缓存区时才需要同步锁定。

            > 虚拟机是否使用TLAB，可通过-XX:+/-UseTLAB参数来设定

4. 内存分配完成之后，虚拟机必须对分配到的内存空间(但不包含对象头)都初始化为零值。

    这步操作保证了对象的实例字段，在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

    > 如果使用了TLAB，此初始化工作，可提前至TLAB分配时顺便进行。

5. 接下来，Java虚拟机还要对对象进行必要的设置。

    例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码(事实上将推迟到真正调用Object::hashCode()方法时才计算)、对象的GC分代年龄等信息。

    这些信息将放在对象头(Object Header)中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头的设置方式将有所不同。

至此，从虚拟机的视角来看，一个新的对象已经产生了。但从Java程序的视角来看，对象创建才刚刚开始——因为Class文件中的<init>()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息还没有按照预定的意图构造好。

> 一般来说，new指令之后会接着执行<init>()方法，按照程序员的意图对对象进行初始化。 这由字节码流中new指令是否跟随invokespecial指令决定。Java编译器会在遇到new关键字的地方，同时生成这两条指令；但如果直接通过其他方式产生的则不一定如此。

# 对象的内存布局

在HotSpot虚拟机里，对象在堆内存中的存储布局，可以划分为三个部分：

- 对象头(Header)
- 实例数据(Instance Data)
- 对齐填充(Padding)

HotSpot虚拟机对象的对象头部分，包含两类信息：

> 此外，如果对象是一个Java数组，对象头中还必须有一块用于记录数组长度的数据

- 第一类是用于存储对象自身的运行时数据。

    如哈希码(Hash Code)，GC分代年龄，锁状态信息，线程持有的锁，偏向线程ID，偏向时间戳等

    这部分数据的长度，在32位和64位的虚拟机(未开启压缩指针)中，分别位32比特和64比特，官方称之为”Mark Word“。

- 第二类是类型指针，即对象指向它的类型元数据的指针。

    Java虚拟机通过这个指针，确定该对象是哪个类的实例。

    但并不是所有的虚拟机实现，都必须在对象数据上保留类型指针。换句话说，查找对象的元数据信息，并不一定要经过对象本身。见[此](https://www.notion.so/HotSpot-3ac3a6e19d7547e383dc21896bcac95c)

HotSpot虚拟机对象的实例数据部分：

是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的内存。无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。

这部分的**存储顺序**，将受到虚拟机分配策略参数(-XX:FieldsAllocationSytle)和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序位longs/doubles，ints，shorts/chars，bytes/booleans，oops(Oridinary Object Pointers, OOPs)，在满足此前提条件的基础上，父类定义的字段出现在子类之前。

> 可见，相同宽度的字段总是被分配到一起存放。 如果虚拟机的+XX:CompactFields参数值为true(默认就是true)，允许子类之中较窄的字段，插入到父类字段的空隙中，以节省空间

HotSpot虚拟机对象的对齐填充部分：

HotSpot虚拟机的自动内存管理系统要求，对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。

对象头部分已经被精心设计成8字节的整数倍(1倍或2倍)。因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补齐。

# 对象的访问定位

创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。但在《Java虚拟机规范》中，仅规定了reference是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置。

因此，对象访问方式也是由虚拟机实现而定的，主流的方式有：

- 使用句柄：

    Java堆中将可能划分出一块内存，来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

    ![Untitled(5)](HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98.assets/Untitled(5).png)

- 直接指针：

    采用此方式时，Java堆中对象的内存布局，就必须考虑如何放置访问类型数据的相关信息。

    reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。

    ![Untitled(4)](HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98.assets/Untitled(4).png)

两种访问方式各有优势：

- 使用句柄来访问的最大好处，就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时，指挥改变句柄中的实例数据指针，而reference本身不需要被修改

- 使用直接指针来访问的最大好处，就是速度更快，节省了一次指针定位的时间开销。

    > HotSpot虚拟机，主要使用此方式进行对象访问。例如的，如果使用了Shenandoah收集器，将会有一次额外的转发