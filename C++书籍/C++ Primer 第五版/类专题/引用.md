# 相关资料

- 视频教程：https://www.bilibili.com/video/BV19S4y137yS





# C++的变量类型

变量的类型，分为：

- 值类型
- 指针类型
- 引用类型





# 左值、右值

C++变量，分为：

- 左值：能取地址

  > 字符串常量，本身是一个变量(const char*)

- 右值：不能取地址

  - 函数的返回值（返回左值引用除外）

    ```C++
    std::string getHello() {
    	return { "hello,world" };
    }
    
    int main() {
    
    	std::cout << getHello() << std::endl;
    }
    ```

  - 构造无名对象：

    ```C++
    int main() {
    
    	std::cout << std::string("hello,world") << std::endl;
    }
    ```

    

# 为什么需要右值引用

```C++
class MyObj {

};

void foo(MyObj&){}

int main() {

	foo(MyObj());	// 错误：因为临时对象是右值
}
```



解决方案：

- 重载该函数，提供一个形参为右值的版本：

  ```C++
  void foo(MyObj){}
  ```

- 使用`const`关键字，修饰左值引用形参：

  ```C++
  class MyObj {
  
  };
  
  void foo(const MyObj&){}
  
  int main() {
  
  	foo(MyObj());
  }
  ```

  > 此时，foo()即可接收左值，又可以接收右值。
  >
  > C++的特性：const的左值引用，遇到一个将亡值，会将这个将亡值的生命周期延长



当一个对象以右值传入，我们并不需要重新开辟空间和拷贝数据，可以直接占用该将亡对象。为此，C++11提供了右值引用。

- 使用拷贝构造：

  ```C++
  buffer(const buffer& other)
  {
  	std::cout << "拷贝构造\n";
  	this->capacity = other.capacity;
  	this->len = other.len;
  	this->buf = new unsigned char[capacity] {};
  	std::copy(other.buf, other.buf + other.capacity, this->buf);
  }
  ```

- 使用移动构造：

  ```C++
  buffer(buffer&& other)
  {
      std::cout << "move拷贝构造\n";
      this->capacity = other.capacity;
      this->len = other.len;
      this->buf = other.buf;
      other.buf = nullptr;
  }
  ```

  

# Copy & Swap模式

一个类 如果我们需要 拷贝和复制，那么我们需要写出如下版本的函数：

- 拷贝构造函数：`buffer(const buffer& other)`
- 移动构造函数：`buffer(buffer&& other)`
- 拷贝赋值函数：`buffer& operator=(const buffer& other)`
- 移动拷贝赋值函数：`buffer& operator=(buffer&& other)`

> 如果我们不需要，使用delete 阻止编译器给我们添加默认的版本
>
> ```C++
> buffer& operator=(buffer const& other) = delete;
> ```



使用swap & copy 模式,可以减少一个函数的代码：

```C++
class Buffer {
public:
	explicit Buffer(int capacity)
		:capacity(capacity), len(0), buf(new unsigned char[capacity] {0})
	{}

	Buffer(Buffer& other)							// 拷贝构造
		:capacity(other.capacity), len(other.len),
		buf(capacity ? new unsigned char[capacity] {0} : nullptr)
	{
		if (capacity) {
			std::copy(other.buf, other.buf + other.capacity, this->buf);
		}
	}

	Buffer(Buffer&& other) noexcept					// 移动构造
		:capacity(0), len(0), buf(nullptr)
	{
		Swap(*this, other);
	}

	Buffer& operator=(Buffer other) noexcept {		// 拷贝赋值
		Swap(*this, other);
		return *this;
	}

	~Buffer() {
		delete[] buf;
	}

	static void Swap(Buffer& lhs, Buffer& rhs)noexcept {
		std::swap(lhs.buf, rhs.buf);
		std::swap(lhs.capacity, rhs.capacity);
		std::swap(lhs.len, rhs.len);
	}

private:
	int capacity;
	int len;
	unsigned char* buf;
};
```



值得说明的是 `buffer& operator=(buffer other)noexcept`：

- 如果传入左值：
  1. 先调用**拷贝构造**，得到形参other
  2. 执行operator()
- 如果传入右值：
  1. 先调用**移动构造**，得到形参other
  2. 执行operator()



```C++
int main() {
	Buffer b(10), b1(10);

	cout << endl;
	b1 = b;

	cout << endl;
	b1 = Buffer(10);	

	cout << endl;
	b1 = std::move(b);
}
```

```.
有参构造
有参构造

拷贝构造
拷贝赋值

有参构造
拷贝赋值

移动构造
拷贝赋值
```



# 完美转发

https://www.bilibili.com/video/BV19S4y137yS?t=1448.7